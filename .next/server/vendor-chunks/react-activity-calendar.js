"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/react-activity-calendar";
exports.ids = ["vendor-chunks/react-activity-calendar"];
exports.modules = {

/***/ "(ssr)/./node_modules/react-activity-calendar/build/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/react-activity-calendar/build/index.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/* __next_internal_client_entry_do_not_use__  cjs */ \nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nvar react = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\nvar dateFns = __webpack_require__(/*! date-fns */ \"(ssr)/./node_modules/date-fns/index.js\");\nvar jsxRuntime = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\nconst NAMESPACE = \"react-activity-calendar\";\nconst LABEL_MARGIN = 8; // px\nconst DEFAULT_MONTH_LABELS = [\n    \"Jan\",\n    \"Feb\",\n    \"Mar\",\n    \"Apr\",\n    \"May\",\n    \"Jun\",\n    \"Jul\",\n    \"Aug\",\n    \"Sep\",\n    \"Oct\",\n    \"Nov\",\n    \"Dec\"\n];\nconst DEFAULT_LABELS = {\n    months: DEFAULT_MONTH_LABELS,\n    weekdays: [\n        \"Sun\",\n        \"Mon\",\n        \"Tue\",\n        \"Wed\",\n        \"Thu\",\n        \"Fri\",\n        \"Sat\"\n    ],\n    totalCount: \"{{count}} activities in {{year}}\",\n    legend: {\n        less: \"Less\",\n        more: \"More\"\n    }\n};\nfunction useColorScheme() {\n    const [colorScheme, setColorScheme] = react.useState(\"light\");\n    const onChange = (event)=>{\n        setColorScheme(event.matches ? \"dark\" : \"light\");\n    };\n    react.useEffect(()=>{\n        const mediaQuery = window.matchMedia(\"(prefers-color-scheme: dark)\");\n        setColorScheme(mediaQuery.matches ? \"dark\" : \"light\");\n        mediaQuery.addEventListener(\"change\", onChange);\n        return ()=>{\n            mediaQuery.removeEventListener(\"change\", onChange);\n        };\n    }, []);\n    return colorScheme;\n}\nconst loadingAnimationName = `${NAMESPACE}--loading-animation`;\nfunction useLoadingAnimation(zeroColor, colorScheme) {\n    react.useEffect(()=>{\n        const colorLoading = `oklab(from ${zeroColor} l a b)`;\n        const colorActive = colorScheme === \"light\" ? `oklab(from ${zeroColor} calc(l * 0.96) a b)` : `oklab(from ${zeroColor} calc(l * 1.08) a b)`;\n        const style = document.createElement(\"style\");\n        style.innerHTML = `\n      @keyframes ${loadingAnimationName} {\n        0% {\n          fill: ${colorLoading};\n        }\n        50% {\n          fill: ${colorActive};\n        }\n        100% {\n          fill: ${colorLoading};\n        }\n      }\n    `;\n        document.head.appendChild(style);\n        return ()=>{\n            document.head.removeChild(style);\n        };\n    }, [\n        zeroColor,\n        colorScheme\n    ]);\n}\nconst query = \"(prefers-reduced-motion: reduce)\";\nfunction usePrefersReducedMotion() {\n    const [prefersReducedMotion, setPrefersReducedMotion] = react.useState(true);\n    react.useEffect(()=>{\n        const mediaQuery = window.matchMedia(query);\n        setPrefersReducedMotion(mediaQuery.matches);\n        const onChange = (event)=>{\n            setPrefersReducedMotion(event.matches);\n        };\n        mediaQuery.addEventListener(\"change\", onChange);\n        return ()=>{\n            mediaQuery.removeEventListener(\"change\", onChange);\n        };\n    }, []);\n    return prefersReducedMotion;\n}\nfunction validateActivities(activities, maxLevel) {\n    if (activities.length === 0) {\n        throw new Error(\"Activity data must not be empty.\");\n    }\n    for (const { date, level, count } of activities){\n        if (!dateFns.isValid(dateFns.parseISO(date))) {\n            throw new Error(`Activity date '${date}' is not a valid ISO 8601 date string.`);\n        }\n        if (count < 0) {\n            throw new RangeError(`Activity count must not be negative, found ${count}.`);\n        }\n        if (level < 0 || level > maxLevel) {\n            throw new RangeError(`Activity level ${level} for ${date} is out of range. It must be between 0 and ${maxLevel}.`);\n        }\n    }\n}\nfunction groupByWeeks(activities, weekStart = 0 // 0 = Sunday\n) {\n    const normalizedActivities = fillHoles(activities);\n    // Determine the first date of the calendar. If the first date is not the\n    // passed weekday, the respective weekday one week earlier is used.\n    const firstActivity = normalizedActivities[0];\n    const firstDate = dateFns.parseISO(firstActivity.date);\n    const firstCalendarDate = dateFns.getDay(firstDate) === weekStart ? firstDate : dateFns.subWeeks(dateFns.nextDay(firstDate, weekStart), 1);\n    // To correctly group activities by week, it is necessary to left-pad the list\n    // because the first date might not be set start weekday.\n    const paddedActivities = [\n        ...Array(dateFns.differenceInCalendarDays(firstDate, firstCalendarDate)).fill(undefined),\n        ...normalizedActivities\n    ];\n    const numberOfWeeks = Math.ceil(paddedActivities.length / 7);\n    // Finally, group activities by week\n    return range(numberOfWeeks).map((weekIndex)=>paddedActivities.slice(weekIndex * 7, weekIndex * 7 + 7));\n}\n/**\n * The calendar expects a continuous sequence of days,\n * so fill gaps with empty activity data.\n */ function fillHoles(activities) {\n    const calendar = new Map(activities.map((a)=>[\n            a.date,\n            a\n        ]));\n    const firstActivity = activities[0];\n    const lastActivity = activities[activities.length - 1];\n    return dateFns.eachDayOfInterval({\n        start: dateFns.parseISO(firstActivity.date),\n        end: dateFns.parseISO(lastActivity.date)\n    }).map((day)=>{\n        const date = dateFns.formatISO(day, {\n            representation: \"date\"\n        });\n        if (calendar.has(date)) {\n            return calendar.get(date);\n        }\n        return {\n            date,\n            count: 0,\n            level: 0\n        };\n    });\n}\nfunction getClassName(name) {\n    return `${NAMESPACE}__${name}`;\n}\nfunction generateEmptyData() {\n    const year = new Date().getFullYear();\n    const days = dateFns.eachDayOfInterval({\n        start: new Date(year, 0, 1),\n        end: new Date(year, 11, 31)\n    });\n    return days.map((date)=>({\n            date: dateFns.formatISO(date, {\n                representation: \"date\"\n            }),\n            count: 0,\n            level: 0\n        }));\n}\nfunction range(n) {\n    return [\n        ...Array(n).keys()\n    ];\n}\nfunction getMonthLabels(weeks, monthNames = DEFAULT_MONTH_LABELS) {\n    return weeks.reduce((labels, week, weekIndex)=>{\n        const firstActivity = week.find((activity)=>activity !== undefined);\n        if (!firstActivity) {\n            throw new Error(`Unexpected error: Week ${weekIndex + 1} is empty.`);\n        }\n        const month = monthNames[dateFns.getMonth(dateFns.parseISO(firstActivity.date))];\n        if (!month) {\n            const monthName = new Date(firstActivity.date).toLocaleString(\"en-US\", {\n                month: \"short\"\n            });\n            throw new Error(`Unexpected error: undefined month label for ${monthName}.`);\n        }\n        const prevLabel = labels[labels.length - 1];\n        if (weekIndex === 0 || !prevLabel || prevLabel.label !== month) {\n            return [\n                ...labels,\n                {\n                    weekIndex,\n                    label: month\n                }\n            ];\n        }\n        return labels;\n    }, []).filter(({ weekIndex }, index, labels)=>{\n        // Labels should only be shown if there is \"enough\" space (data).\n        // This is a naive implementation that does not take the block size,\n        // font size, etc. into account.\n        const minWeeks = 3;\n        // Skip the first month label if there is not enough space to the next one.\n        if (index === 0) {\n            return labels[1] && labels[1].weekIndex - weekIndex >= minWeeks;\n        }\n        // Skip the last month label if there is not enough data in that month\n        // to avoid overflowing the calendar on the right.\n        if (index === labels.length - 1) {\n            return weeks.slice(weekIndex).length >= minWeeks;\n        }\n        return true;\n    });\n}\nfunction maxWeekdayLabelWidth(labels, showWeekdayLabel, fontSize) {\n    if (labels.length !== 7) {\n        throw new Error(\"Exactly 7 labels, one for each weekday must be passed.\");\n    }\n    return labels.reduce((maxWidth, label, index)=>showWeekdayLabel.byDayIndex(index) ? Math.max(maxWidth, Math.ceil(calcTextDimensions(label, fontSize).width)) : maxWidth, 0);\n}\nfunction calcTextDimensions(text, fontSize) {\n    if (typeof document === \"undefined\" || \"undefined\" === \"undefined\") {\n        return {\n            width: 0,\n            height: 0\n        };\n    }\n    if (fontSize < 1) {\n        throw new RangeError(\"fontSize must be positive\");\n    }\n    if (text.length === 0) {\n        return {\n            width: 0,\n            height: 0\n        };\n    }\n    const namespace = \"http://www.w3.org/2000/svg\";\n    const svg = document.createElementNS(namespace, \"svg\");\n    svg.style.position = \"absolute\";\n    svg.style.visibility = \"hidden\";\n    svg.style.fontFamily = window.getComputedStyle(document.body).fontFamily;\n    svg.style.fontSize = `${fontSize}px`;\n    const textNode = document.createElementNS(namespace, \"text\");\n    textNode.textContent = text;\n    svg.appendChild(textNode);\n    document.body.appendChild(svg);\n    const boundingBox = textNode.getBBox();\n    document.body.removeChild(svg);\n    return {\n        width: boundingBox.width,\n        height: boundingBox.height\n    };\n}\nfunction initWeekdayLabels(input, weekStart) {\n    if (!input) return {\n        byDayIndex: ()=>false,\n        shouldShow: false\n    };\n    // Default: Show every second day of the week.\n    if (input === true) {\n        return {\n            byDayIndex: (index)=>{\n                return (7 + index - weekStart) % 7 % 2 !== 0;\n            },\n            shouldShow: true\n        };\n    }\n    const indexed = [];\n    for (const name of input){\n        const index = dayNameToIndex[name.toLowerCase()];\n        indexed[index] = true;\n    }\n    return {\n        byDayIndex: (index)=>indexed[index] ?? false,\n        shouldShow: input.length > 0\n    };\n}\nconst dayNameToIndex = {\n    sun: 0,\n    mon: 1,\n    tue: 2,\n    wed: 3,\n    thu: 4,\n    fri: 5,\n    sat: 6\n};\nfunction createTheme(input, steps = 5) {\n    const defaultTheme = createDefaultTheme(steps);\n    if (input) {\n        validateInput(input, steps);\n        input.light = input.light ?? defaultTheme.light;\n        input.dark = input.dark ?? defaultTheme.dark;\n        return {\n            light: isPair(input.light) ? calcColorScale(input.light, steps) : input.light,\n            dark: isPair(input.dark) ? calcColorScale(input.dark, steps) : input.dark\n        };\n    }\n    return defaultTheme;\n}\nfunction createDefaultTheme(steps) {\n    return {\n        light: calcColorScale([\n            \"hsl(0, 0%, 92%)\",\n            \"hsl(0, 0%, 26%)\"\n        ], steps),\n        dark: calcColorScale([\n            \"hsl(0, 0%, 22%)\",\n            \"hsl(0, 0%, 92%)\"\n        ], steps)\n    };\n}\nfunction validateInput(input, steps) {\n    if (typeof input !== \"object\" || input.light === undefined && input.dark === undefined) {\n        throw new Error(`The theme object must contain at least one of the fields \"light\" and \"dark\" with exactly 2 or ${steps} colors respectively.`);\n    }\n    if (input.light) {\n        const { length } = input.light;\n        if (length !== 2 && length !== steps) {\n            throw new Error(`theme.light must contain exactly 2 or ${steps} colors, ${length} passed.`);\n        }\n        for (const c of input.light){\n            if (false) {}\n        }\n    }\n    if (input.dark) {\n        const { length } = input.dark;\n        if (length !== 2 && length !== steps) {\n            throw new Error(`theme.dark must contain exactly 2 or ${steps} colors, ${length} passed.`);\n        }\n        for (const c of input.dark){\n            if (false) {}\n        }\n    }\n}\nfunction calcColorScale([start, end], steps) {\n    return range(steps).map((i)=>{\n        // In the loading animation the zero color is used.\n        // However, Safari 16 crashes if a CSS color-mix expression like below is\n        // combined with relative color syntax to calculate a hue variation for the\n        // animation. Since the start and end colors do not need to be mixed, they\n        // can be returned directly to work around this issue.\n        switch(i){\n            case 0:\n                return start;\n            case steps - 1:\n                return end;\n            default:\n                {\n                    const pos = i / (steps - 1) * 100;\n                    return `color-mix(in oklab, ${end} ${parseFloat(pos.toFixed(2))}%, ${start})`;\n                }\n        }\n    });\n}\nfunction isPair(val) {\n    return val.length === 2;\n}\nconst styles = {\n    container: (fontSize)=>({\n            width: \"max-content\",\n            // Calendar should not grow\n            maxWidth: \"100%\",\n            // Do not remove - parent might be a flexbox\n            display: \"flex\",\n            flexDirection: \"column\",\n            gap: \"8px\",\n            fontSize: `${fontSize}px`\n        }),\n    scrollContainer: (fontSize)=>({\n            maxWidth: \"100%\",\n            overflowX: \"auto\",\n            overflowY: \"hidden\",\n            paddingTop: Math.ceil(0.1 * fontSize) // SVG <text> overflows in Firefox at y=0\n        }),\n    calendar: {\n        display: \"block\",\n        // SVGs are inline-block by default\n        overflow: \"visible\" // Weekday labels are rendered left of the container\n    },\n    rect: (colorScheme)=>({\n            stroke: colorScheme === \"light\" ? \"rgba(0, 0, 0, 0.08)\" : \"rgba(255, 255, 255, 0.04)\"\n        }),\n    footer: {\n        container: {\n            display: \"flex\",\n            flexWrap: \"wrap\",\n            gap: \"4px 16px\",\n            whiteSpace: \"nowrap\"\n        },\n        legend: {\n            marginLeft: \"auto\",\n            display: \"flex\",\n            alignItems: \"center\",\n            gap: \"3px\"\n        }\n    }\n};\nconst ActivityCalendar = /*#__PURE__*/ react.forwardRef(({ data: activities, blockMargin = 4, blockRadius = 2, blockSize = 12, colorScheme: colorSchemeProp = undefined, eventHandlers = {}, fontSize = 14, hideColorLegend = false, hideMonthLabels = false, hideTotalCount = false, labels: labelsProp = undefined, maxLevel = 4, loading = false, renderBlock = undefined, renderColorLegend = undefined, showWeekdayLabels = false, style: styleProp = {}, theme: themeProp = undefined, totalCount: totalCountProp = undefined, weekStart = 0 // Sunday\n }, // Required for react-docgen\nref)=>{\n    const [isClient, setIsClient] = react.useState(false);\n    react.useEffect(()=>{\n        setIsClient(true);\n    }, []);\n    maxLevel = Math.max(1, maxLevel);\n    const theme = createTheme(themeProp, maxLevel + 1);\n    const systemColorScheme = useColorScheme();\n    const colorScheme = colorSchemeProp ?? systemColorScheme;\n    const colorScale = theme[colorScheme];\n    useLoadingAnimation(colorScale[0], colorScheme);\n    const useAnimation = !usePrefersReducedMotion();\n    if (loading) {\n        activities = generateEmptyData();\n    }\n    validateActivities(activities, maxLevel);\n    const firstActivity = activities[0];\n    const year = dateFns.getYear(dateFns.parseISO(firstActivity.date));\n    const weeks = groupByWeeks(activities, weekStart);\n    const labels = Object.assign({}, DEFAULT_LABELS, labelsProp);\n    const labelHeight = hideMonthLabels ? 0 : fontSize + LABEL_MARGIN;\n    const weekdayLabels = initWeekdayLabels(showWeekdayLabels, weekStart);\n    // Must be calculated on the client or SSR hydration errors will occur\n    // because server and client HTML would not match.\n    const weekdayLabelOffset = isClient && weekdayLabels.shouldShow ? maxWeekdayLabelWidth(labels.weekdays, weekdayLabels, fontSize) + LABEL_MARGIN : undefined;\n    function getDimensions() {\n        return {\n            width: weeks.length * (blockSize + blockMargin) - blockMargin,\n            height: labelHeight + (blockSize + blockMargin) * 7 - blockMargin\n        };\n    }\n    function getEventHandlers(activity) {\n        return Object.keys(eventHandlers).reduce((handlers, key)=>({\n                ...handlers,\n                [key]: (event)=>eventHandlers[key]?.(event)(activity)\n            }), {});\n    }\n    function renderCalendar() {\n        return weeks.map((week, weekIndex)=>week.map((activity, dayIndex)=>{\n                if (!activity) {\n                    return null;\n                }\n                const loadingAnimation = loading && useAnimation ? {\n                    animation: `${loadingAnimationName} 1.75s ease-in-out infinite`,\n                    animationDelay: `${weekIndex * 20 + dayIndex * 20}ms`\n                } : undefined;\n                const block = /*#__PURE__*/ jsxRuntime.jsx(\"rect\", {\n                    ...getEventHandlers(activity),\n                    x: 0,\n                    y: labelHeight + (blockSize + blockMargin) * dayIndex,\n                    width: blockSize,\n                    height: blockSize,\n                    rx: blockRadius,\n                    ry: blockRadius,\n                    fill: colorScale[activity.level],\n                    \"data-date\": activity.date,\n                    \"data-level\": activity.level,\n                    style: {\n                        ...styles.rect(colorScheme),\n                        ...loadingAnimation\n                    }\n                });\n                return /*#__PURE__*/ jsxRuntime.jsx(react.Fragment, {\n                    children: renderBlock ? renderBlock(block, activity) : block\n                }, activity.date);\n            })).map((week, x)=>/*#__PURE__*/ jsxRuntime.jsx(\"g\", {\n                transform: `translate(${(blockSize + blockMargin) * x}, 0)`,\n                children: week\n            }, x));\n    }\n    function renderFooter() {\n        if (hideTotalCount && hideColorLegend) {\n            return null;\n        }\n        const totalCount = typeof totalCountProp === \"number\" ? totalCountProp : activities.reduce((sum, activity)=>sum + activity.count, 0);\n        return /*#__PURE__*/ jsxRuntime.jsxs(\"footer\", {\n            className: getClassName(\"footer\"),\n            style: {\n                ...styles.footer.container,\n                marginLeft: weekdayLabelOffset\n            },\n            children: [\n                loading && /*#__PURE__*/ jsxRuntime.jsx(\"div\", {\n                    children: \"\\xa0\"\n                }),\n                !loading && !hideTotalCount && /*#__PURE__*/ jsxRuntime.jsx(\"div\", {\n                    className: getClassName(\"count\"),\n                    children: labels.totalCount ? labels.totalCount.replace(\"{{count}}\", String(totalCount)).replace(\"{{year}}\", String(year)) : `${totalCount} activities in ${year}`\n                }),\n                !loading && !hideColorLegend && /*#__PURE__*/ jsxRuntime.jsxs(\"div\", {\n                    className: getClassName(\"legend-colors\"),\n                    style: styles.footer.legend,\n                    children: [\n                        /*#__PURE__*/ jsxRuntime.jsx(\"span\", {\n                            style: {\n                                marginRight: \"0.4em\"\n                            },\n                            children: labels.legend.less\n                        }),\n                        range(maxLevel + 1).map((level)=>{\n                            const block = /*#__PURE__*/ jsxRuntime.jsx(\"svg\", {\n                                width: blockSize,\n                                height: blockSize,\n                                children: /*#__PURE__*/ jsxRuntime.jsx(\"rect\", {\n                                    width: blockSize,\n                                    height: blockSize,\n                                    fill: colorScale[level],\n                                    rx: blockRadius,\n                                    ry: blockRadius,\n                                    style: styles.rect(colorScheme)\n                                })\n                            }, level);\n                            return renderColorLegend ? renderColorLegend(block, level) : block;\n                        }),\n                        /*#__PURE__*/ jsxRuntime.jsx(\"span\", {\n                            style: {\n                                marginLeft: \"0.4em\"\n                            },\n                            children: labels.legend.more\n                        })\n                    ]\n                })\n            ]\n        });\n    }\n    function renderWeekdayLabels() {\n        if (!weekdayLabels.shouldShow) {\n            return null;\n        }\n        return /*#__PURE__*/ jsxRuntime.jsx(\"g\", {\n            className: getClassName(\"legend-weekday\"),\n            children: range(7).map((index)=>{\n                const dayIndex = (index + weekStart) % 7;\n                if (!weekdayLabels.byDayIndex(dayIndex)) {\n                    return null;\n                }\n                return /*#__PURE__*/ jsxRuntime.jsx(\"text\", {\n                    x: -8,\n                    y: labelHeight + (blockSize + blockMargin) * index + blockSize / 2,\n                    dominantBaseline: \"central\",\n                    textAnchor: \"end\",\n                    fill: \"currentColor\",\n                    children: labels.weekdays[dayIndex]\n                }, index);\n            })\n        });\n    }\n    function renderMonthLabels() {\n        if (hideMonthLabels) {\n            return null;\n        }\n        return /*#__PURE__*/ jsxRuntime.jsx(\"g\", {\n            className: getClassName(\"legend-month\"),\n            children: getMonthLabels(weeks, labels.months).map(({ label, weekIndex })=>/*#__PURE__*/ jsxRuntime.jsx(\"text\", {\n                    x: (blockSize + blockMargin) * weekIndex,\n                    y: 0,\n                    dominantBaseline: \"hanging\",\n                    fill: \"currentColor\",\n                    children: label\n                }, weekIndex))\n        });\n    }\n    const { width, height } = getDimensions();\n    return /*#__PURE__*/ jsxRuntime.jsxs(\"article\", {\n        ref: ref,\n        className: NAMESPACE,\n        style: {\n            ...styleProp,\n            ...styles.container(fontSize)\n        },\n        children: [\n            /*#__PURE__*/ jsxRuntime.jsx(\"div\", {\n                className: getClassName(\"scroll-container\"),\n                style: styles.scrollContainer(fontSize),\n                children: /*#__PURE__*/ jsxRuntime.jsxs(\"svg\", {\n                    width: width,\n                    height: height,\n                    viewBox: `0 0 ${width} ${height}`,\n                    className: getClassName(\"calendar\"),\n                    style: {\n                        ...styles.calendar,\n                        marginLeft: weekdayLabelOffset\n                    },\n                    children: [\n                        !loading && renderWeekdayLabels(),\n                        !loading && renderMonthLabels(),\n                        renderCalendar()\n                    ]\n                })\n            }),\n            renderFooter()\n        ]\n    });\n});\nActivityCalendar.displayName = \"ActivityCalendar\";\nconst Skeleton = (props)=>/*#__PURE__*/ jsxRuntime.jsx(ActivityCalendar, {\n        data: [],\n        ...props\n    });\nexports.ActivityCalendar = ActivityCalendar;\nexports.Skeleton = Skeleton;\nexports[\"default\"] = ActivityCalendar; //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtYWN0aXZpdHktY2FsZW5kYXIvYnVpbGQvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFPLE1BQU1BLFlBQVk7QUFDbEIsTUFBTUMsZUFBZSxHQUFFO0FBRXZCLE1BQU1DLHVCQUF1QjtJQUNsQztJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7Q0FDRDtBQUVNLE1BQU1DLGlCQUFpQjtJQUM1QkMsUUFBUUY7SUFDUkcsVUFBVTtRQUFDO1FBQU87UUFBTztRQUFPO1FBQU87UUFBTztRQUFPO0tBQU07SUFDM0RDLFlBQVk7SUFDWkMsUUFBUTtRQUNOQyxNQUFNO1FBQ05DLE1BQU07SUFDUjtBQUNGO0FDeEJPLFNBQVNDO0lBQ2QsTUFBTSxDQUFDQyxhQUFhQyxlQUFlLEdBQUdDLE1BQUFBLFFBQVEsQ0FBbUI7SUFFakUsTUFBTUMsV0FBWUMsQ0FBQUE7UUFDaEJILGVBQWVHLE1BQU1DLE9BQU8sR0FBRyxTQUFTOztJQUcxQ0MsTUFBQUEsU0FBUyxDQUFDO1FBQ1IsTUFBTUMsYUFBYUMsT0FBT0MsVUFBVSxDQUFDO1FBQ3JDUixlQUFlTSxXQUFXRixPQUFPLEdBQUcsU0FBUztRQUU3Q0UsV0FBV0csZ0JBQWdCLENBQUMsVUFBVVA7UUFFdEMsT0FBTztZQUNMSSxXQUFXSSxtQkFBbUIsQ0FBQyxVQUFVUjs7T0FFMUMsRUFBRTtJQUVMLE9BQU9IO0FBQ1Q7QUNsQk8sTUFBTVksdUJBQXVCLEdBQUd2QixVQUE4QjtBQUU5RCxTQUFTd0Isb0JBQW9CQyxTQUFpQixFQUFFZCxXQUE2QjtJQUNsRk0sTUFBQUEsU0FBUyxDQUFDO1FBQ1IsTUFBTVMsZUFBZSxDQUFjRCxXQUFBQSxFQUFBQSxVQUFrQjtRQUNyRCxNQUFNRSxjQUNKaEIsZ0JBQWdCLFVBQ1osQ0FBY2MsV0FBQUEsRUFBQUEsVUFBK0Isd0JBQzdDLENBQWNBLFdBQUFBLEVBQUFBLFVBQStCO1FBRW5ELE1B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RUFBUSxHQUFHNkY7SUFFMUIscUJBQ0VvQixXQUFBQSxJQUFBO1FBQ0VoQyxLQUFLQTtRQUNMaUMsV0FBV3pPO1FBQ1g0QixPQUFPO1lBQUUsR0FBR3dLLFNBQVM7WUFBRSxHQUFHakMsT0FBT0MsU0FBUyxDQUFDcEQsU0FBUTs7UUFBSW9ILFVBQUE7WUFBQSxjQUV2RE4sV0FBQUEsR0FBQTtnQkFBS1csV0FBV3JKLGFBQWE7Z0JBQXFCeEQsT0FBT3VJLE9BQU9LLGVBQWUsQ0FBQ3hEO2dCQUFVb0gsVUFBQSxjQUN4RkksV0FBQUEsSUFBQTtvQkFDRW5ILE9BQU9BO29CQUNQRSxRQUFRQTtvQkFDUnlILFNBQVMsT0FBTzNILE1BQUssR0FBSUUsT0FBUztvQkFDbENrSCxXQUFXckosYUFBYTtvQkFDeEJ4RCxPQUFPO3dCQUFFLEdBQUd1SSxPQUFPM0YsUUFBUTt3QkFBRTBHLFlBQVlpQzs7b0JBQXFCaUIsVUFBQTt3QkFFN0QsQ0FBQ3BDLFdBQVc0Qzt3QkFDWixDQUFDNUMsV0FBVytDO3dCQUNadkI7cUJBQWdCOztZQUNiO1lBRVBjO1NBQWM7SUFBQTtBQUdyQjtBQUdGbEQsaUJBQWlCNkQsV0FBVyxHQUFHO01BRWxCQyxXQUFZQyxDQUFBQSxRQUEwQixjQUFLckIsV0FBQUEsR0FBQSxDQUFDMUMsa0JBQWdCO1FBQUNFLE1BQU0sRUFBRztRQUFBLEdBQUs2RCxLQUFBQTtJQUFLIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcG9yZm9saW8vLi4vc3JjL2NvbnN0YW50cy50cz9iMTNlIiwid2VicGFjazovL3BvcmZvbGlvLy4uL3NyYy9ob29rcy91c2VDb2xvclNjaGVtZS50cz83OWM3Iiwid2VicGFjazovL3BvcmZvbGlvLy4uL3NyYy9ob29rcy91c2VMb2FkaW5nQW5pbWF0aW9uLnRzP2NiNmIiLCJ3ZWJwYWNrOi8vcG9yZm9saW8vLi4vc3JjL2hvb2tzL3VzZVByZWZlcnNSZWR1Y2VkTW90aW9uLnRzPzc5OWMiLCJ3ZWJwYWNrOi8vcG9yZm9saW8vLi4vc3JjL2xpYi9jYWxlbmRhci50cz82ZTI1Iiwid2VicGFjazovL3BvcmZvbGlvLy4uL3NyYy9saWIvbGFiZWwudHM/MGE1ZSIsIndlYnBhY2s6Ly9wb3Jmb2xpby8uLi9zcmMvbGliL3RoZW1lLnRzPzdkMzIiLCJ3ZWJwYWNrOi8vcG9yZm9saW8vLi4vc3JjL2NvbXBvbmVudC9zdHlsZXMudHM/MzI5NCIsIndlYnBhY2s6Ly9wb3Jmb2xpby8uLi9zcmMvY29tcG9uZW50L0FjdGl2aXR5Q2FsZW5kYXIudHN4PzRiODMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGNvbnN0IE5BTUVTUEFDRSA9ICdyZWFjdC1hY3Rpdml0eS1jYWxlbmRhcidcbmV4cG9ydCBjb25zdCBMQUJFTF9NQVJHSU4gPSA4IC8vIHB4XG5cbmV4cG9ydCBjb25zdCBERUZBVUxUX01PTlRIX0xBQkVMUyA9IFtcbiAgJ0phbicsXG4gICdGZWInLFxuICAnTWFyJyxcbiAgJ0FwcicsXG4gICdNYXknLFxuICAnSnVuJyxcbiAgJ0p1bCcsXG4gICdBdWcnLFxuICAnU2VwJyxcbiAgJ09jdCcsXG4gICdOb3YnLFxuICAnRGVjJyxcbl1cblxuZXhwb3J0IGNvbnN0IERFRkFVTFRfTEFCRUxTID0ge1xuICBtb250aHM6IERFRkFVTFRfTU9OVEhfTEFCRUxTLFxuICB3ZWVrZGF5czogWydTdW4nLCAnTW9uJywgJ1R1ZScsICdXZWQnLCAnVGh1JywgJ0ZyaScsICdTYXQnXSxcbiAgdG90YWxDb3VudDogJ3t7Y291bnR9fSBhY3Rpdml0aWVzIGluIHt7eWVhcn19JyxcbiAgbGVnZW5kOiB7XG4gICAgbGVzczogJ0xlc3MnLFxuICAgIG1vcmU6ICdNb3JlJyxcbiAgfSxcbn1cbiIsImltcG9ydCB7IHVzZUVmZmVjdCwgdXNlU3RhdGUgfSBmcm9tICdyZWFjdCdcblxuZXhwb3J0IGZ1bmN0aW9uIHVzZUNvbG9yU2NoZW1lKCkge1xuICBjb25zdCBbY29sb3JTY2hlbWUsIHNldENvbG9yU2NoZW1lXSA9IHVzZVN0YXRlPCdsaWdodCcgfCAnZGFyayc+KCdsaWdodCcpXG5cbiAgY29uc3Qgb25DaGFuZ2UgPSAoZXZlbnQ6IE1lZGlhUXVlcnlMaXN0RXZlbnQpID0+IHtcbiAgICBzZXRDb2xvclNjaGVtZShldmVudC5tYXRjaGVzID8gJ2RhcmsnIDogJ2xpZ2h0JylcbiAgfVxuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3QgbWVkaWFRdWVyeSA9IHdpbmRvdy5tYXRjaE1lZGlhKCcocHJlZmVycy1jb2xvci1zY2hlbWU6IGRhcmspJylcbiAgICBzZXRDb2xvclNjaGVtZShtZWRpYVF1ZXJ5Lm1hdGNoZXMgPyAnZGFyaycgOiAnbGlnaHQnKVxuXG4gICAgbWVkaWFRdWVyeS5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCBvbkNoYW5nZSlcblxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBtZWRpYVF1ZXJ5LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIG9uQ2hhbmdlKVxuICAgIH1cbiAgfSwgW10pXG5cbiAgcmV0dXJuIGNvbG9yU2NoZW1lXG59XG4iLCJpbXBvcnQgeyB1c2VFZmZlY3QgfSBmcm9tICdyZWFjdCdcbmltcG9ydCB7IE5BTUVTUEFDRSB9IGZyb20gJy4uL2NvbnN0YW50cydcblxuZXhwb3J0IGNvbnN0IGxvYWRpbmdBbmltYXRpb25OYW1lID0gYCR7TkFNRVNQQUNFfS0tbG9hZGluZy1hbmltYXRpb25gXG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VMb2FkaW5nQW5pbWF0aW9uKHplcm9Db2xvcjogc3RyaW5nLCBjb2xvclNjaGVtZTogJ2xpZ2h0JyB8ICdkYXJrJykge1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IGNvbG9yTG9hZGluZyA9IGBva2xhYihmcm9tICR7emVyb0NvbG9yfSBsIGEgYilgXG4gICAgY29uc3QgY29sb3JBY3RpdmUgPVxuICAgICAgY29sb3JTY2hlbWUgPT09ICdsaWdodCdcbiAgICAgICAgPyBgb2tsYWIoZnJvbSAke3plcm9Db2xvcn0gY2FsYyhsICogMC45NikgYSBiKWBcbiAgICAgICAgOiBgb2tsYWIoZnJvbSAke3plcm9Db2xvcn0gY2FsYyhsICogMS4wOCkgYSBiKWBcblxuICAgIGNvbnN0IHN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKVxuICAgIHN0eWxlLmlubmVySFRNTCA9IGBcbiAgICAgIEBrZXlmcmFtZXMgJHtsb2FkaW5nQW5pbWF0aW9uTmFtZX0ge1xuICAgICAgICAwJSB7XG4gICAgICAgICAgZmlsbDogJHtjb2xvckxvYWRpbmd9O1xuICAgICAgICB9XG4gICAgICAgIDUwJSB7XG4gICAgICAgICAgZmlsbDogJHtjb2xvckFjdGl2ZX07XG4gICAgICAgIH1cbiAgICAgICAgMTAwJSB7XG4gICAgICAgICAgZmlsbDogJHtjb2xvckxvYWRpbmd9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgYFxuICAgIGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoc3R5bGUpXG5cbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgZG9jdW1lbnQuaGVhZC5yZW1vdmVDaGlsZChzdHlsZSlcbiAgICB9XG4gIH0sIFt6ZXJvQ29sb3IsIGNvbG9yU2NoZW1lXSlcbn1cbiIsImltcG9ydCB7IHVzZUVmZmVjdCwgdXNlU3RhdGUgfSBmcm9tICdyZWFjdCdcblxuY29uc3QgcXVlcnkgPSAnKHByZWZlcnMtcmVkdWNlZC1tb3Rpb246IHJlZHVjZSknXG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VQcmVmZXJzUmVkdWNlZE1vdGlvbigpIHtcbiAgY29uc3QgW3ByZWZlcnNSZWR1Y2VkTW90aW9uLCBzZXRQcmVmZXJzUmVkdWNlZE1vdGlvbl0gPSB1c2VTdGF0ZSh0cnVlKVxuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3QgbWVkaWFRdWVyeSA9IHdpbmRvdy5tYXRjaE1lZGlhKHF1ZXJ5KVxuICAgIHNldFByZWZlcnNSZWR1Y2VkTW90aW9uKG1lZGlhUXVlcnkubWF0Y2hlcylcblxuICAgIGNvbnN0IG9uQ2hhbmdlID0gKGV2ZW50OiBNZWRpYVF1ZXJ5TGlzdEV2ZW50KSA9PiB7XG4gICAgICBzZXRQcmVmZXJzUmVkdWNlZE1vdGlvbihldmVudC5tYXRjaGVzKVxuICAgIH1cblxuICAgIG1lZGlhUXVlcnkuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgb25DaGFuZ2UpXG5cbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgbWVkaWFRdWVyeS5yZW1vdmVFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCBvbkNoYW5nZSlcbiAgICB9XG4gIH0sIFtdKVxuXG4gIHJldHVybiBwcmVmZXJzUmVkdWNlZE1vdGlvblxufVxuIiwiaW1wb3J0IHtcbiAgZGlmZmVyZW5jZUluQ2FsZW5kYXJEYXlzLFxuICBlYWNoRGF5T2ZJbnRlcnZhbCxcbiAgZW5kT2ZZZWFyLFxuICBmb3JtYXRJU08sXG4gIGdldERheSxcbiAgaXNWYWxpZCxcbiAgbmV4dERheSxcbiAgcGFyc2VJU08sXG4gIHN0YXJ0T2ZZZWFyLFxuICBzdWJXZWVrcyxcbn0gZnJvbSAnZGF0ZS1mbnMnXG5pbXBvcnQgeyBOQU1FU1BBQ0UgfSBmcm9tICcuLi9jb25zdGFudHMnXG5pbXBvcnQgdHlwZSB7IEFjdGl2aXR5LCBEYXlJbmRleCwgV2VlayB9IGZyb20gJy4uL3R5cGVzJ1xuXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVBY3Rpdml0aWVzKGFjdGl2aXRpZXM6IEFycmF5PEFjdGl2aXR5PiwgbWF4TGV2ZWw6IG51bWJlcikge1xuICBpZiAoYWN0aXZpdGllcy5sZW5ndGggPT09IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0FjdGl2aXR5IGRhdGEgbXVzdCBub3QgYmUgZW1wdHkuJylcbiAgfVxuXG4gIGZvciAoY29uc3QgeyBkYXRlLCBsZXZlbCwgY291bnQgfSBvZiBhY3Rpdml0aWVzKSB7XG4gICAgaWYgKCFpc1ZhbGlkKHBhcnNlSVNPKGRhdGUpKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBBY3Rpdml0eSBkYXRlICcke2RhdGV9JyBpcyBub3QgYSB2YWxpZCBJU08gODYwMSBkYXRlIHN0cmluZy5gKVxuICAgIH1cblxuICAgIGlmIChjb3VudCA8IDApIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBBY3Rpdml0eSBjb3VudCBtdXN0IG5vdCBiZSBuZWdhdGl2ZSwgZm91bmQgJHtjb3VudH0uYClcbiAgICB9XG5cbiAgICBpZiAobGV2ZWwgPCAwIHx8IGxldmVsID4gbWF4TGV2ZWwpIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFxuICAgICAgICBgQWN0aXZpdHkgbGV2ZWwgJHtsZXZlbH0gZm9yICR7ZGF0ZX0gaXMgb3V0IG9mIHJhbmdlLiBJdCBtdXN0IGJlIGJldHdlZW4gMCBhbmQgJHttYXhMZXZlbH0uYCxcbiAgICAgIClcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdyb3VwQnlXZWVrcyhcbiAgYWN0aXZpdGllczogQXJyYXk8QWN0aXZpdHk+LFxuICB3ZWVrU3RhcnQ6IERheUluZGV4ID0gMCwgLy8gMCA9IFN1bmRheVxuKTogQXJyYXk8V2Vlaz4ge1xuICBjb25zdCBub3JtYWxpemVkQWN0aXZpdGllcyA9IGZpbGxIb2xlcyhhY3Rpdml0aWVzKVxuXG4gIC8vIERldGVybWluZSB0aGUgZmlyc3QgZGF0ZSBvZiB0aGUgY2FsZW5kYXIuIElmIHRoZSBmaXJzdCBkYXRlIGlzIG5vdCB0aGVcbiAgLy8gcGFzc2VkIHdlZWtkYXksIHRoZSByZXNwZWN0aXZlIHdlZWtkYXkgb25lIHdlZWsgZWFybGllciBpcyB1c2VkLlxuICBjb25zdCBmaXJzdEFjdGl2aXR5ID0gbm9ybWFsaXplZEFjdGl2aXRpZXNbMF0gYXMgQWN0aXZpdHlcbiAgY29uc3QgZmlyc3REYXRlID0gcGFyc2VJU08oZmlyc3RBY3Rpdml0eS5kYXRlKVxuICBjb25zdCBmaXJzdENhbGVuZGFyRGF0ZSA9XG4gICAgZ2V0RGF5KGZpcnN0RGF0ZSkgPT09IHdlZWtTdGFydCA/IGZpcnN0RGF0ZSA6IHN1YldlZWtzKG5leHREYXkoZmlyc3REYXRlLCB3ZWVrU3RhcnQpLCAxKVxuXG4gIC8vIFRvIGNvcnJlY3RseSBncm91cCBhY3Rpdml0aWVzIGJ5IHdlZWssIGl0IGlzIG5lY2Vzc2FyeSB0byBsZWZ0LXBhZCB0aGUgbGlzdFxuICAvLyBiZWNhdXNlIHRoZSBmaXJzdCBkYXRlIG1pZ2h0IG5vdCBiZSBzZXQgc3RhcnQgd2Vla2RheS5cbiAgY29uc3QgcGFkZGVkQWN0aXZpdGllcyA9IFtcbiAgICAuLi4oQXJyYXkoZGlmZmVyZW5jZUluQ2FsZW5kYXJEYXlzKGZpcnN0RGF0ZSwgZmlyc3RDYWxlbmRhckRhdGUpKS5maWxsKFxuICAgICAgdW5kZWZpbmVkLFxuICAgICkgYXMgQXJyYXk8QWN0aXZpdHk+KSxcbiAgICAuLi5ub3JtYWxpemVkQWN0aXZpdGllcyxcbiAgXVxuXG4gIGNvbnN0IG51bWJlck9mV2Vla3MgPSBNYXRoLmNlaWwocGFkZGVkQWN0aXZpdGllcy5sZW5ndGggLyA3KVxuXG4gIC8vIEZpbmFsbHksIGdyb3VwIGFjdGl2aXRpZXMgYnkgd2Vla1xuICByZXR1cm4gcmFuZ2UobnVtYmVyT2ZXZWVrcykubWFwKHdlZWtJbmRleCA9PlxuICAgIHBhZGRlZEFjdGl2aXRpZXMuc2xpY2Uod2Vla0luZGV4ICogNywgd2Vla0luZGV4ICogNyArIDcpLFxuICApXG59XG5cbi8qKlxuICogVGhlIGNhbGVuZGFyIGV4cGVjdHMgYSBjb250aW51b3VzIHNlcXVlbmNlIG9mIGRheXMsXG4gKiBzbyBmaWxsIGdhcHMgd2l0aCBlbXB0eSBhY3Rpdml0eSBkYXRhLlxuICovXG5mdW5jdGlvbiBmaWxsSG9sZXMoYWN0aXZpdGllczogQXJyYXk8QWN0aXZpdHk+KTogQXJyYXk8QWN0aXZpdHk+IHtcbiAgY29uc3QgY2FsZW5kYXIgPSBuZXcgTWFwPHN0cmluZywgQWN0aXZpdHk+KGFjdGl2aXRpZXMubWFwKGEgPT4gW2EuZGF0ZSwgYV0pKVxuICBjb25zdCBmaXJzdEFjdGl2aXR5ID0gYWN0aXZpdGllc1swXSBhcyBBY3Rpdml0eVxuICBjb25zdCBsYXN0QWN0aXZpdHkgPSBhY3Rpdml0aWVzW2FjdGl2aXRpZXMubGVuZ3RoIC0gMV0gYXMgQWN0aXZpdHlcblxuICByZXR1cm4gZWFjaERheU9mSW50ZXJ2YWwoe1xuICAgIHN0YXJ0OiBwYXJzZUlTTyhmaXJzdEFjdGl2aXR5LmRhdGUpLFxuICAgIGVuZDogcGFyc2VJU08obGFzdEFjdGl2aXR5LmRhdGUpLFxuICB9KS5tYXAoZGF5ID0+IHtcbiAgICBjb25zdCBkYXRlID0gZm9ybWF0SVNPKGRheSwgeyByZXByZXNlbnRhdGlvbjogJ2RhdGUnIH0pXG5cbiAgICBpZiAoY2FsZW5kYXIuaGFzKGRhdGUpKSB7XG4gICAgICByZXR1cm4gY2FsZW5kYXIuZ2V0KGRhdGUpIGFzIEFjdGl2aXR5XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGRhdGUsXG4gICAgICBjb3VudDogMCxcbiAgICAgIGxldmVsOiAwLFxuICAgIH1cbiAgfSlcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldENsYXNzTmFtZShuYW1lOiBzdHJpbmcpIHtcbiAgcmV0dXJuIGAke05BTUVTUEFDRX1fXyR7bmFtZX1gXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZW5lcmF0ZUVtcHR5RGF0YSgpOiBBcnJheTxBY3Rpdml0eT4ge1xuICBjb25zdCB5ZWFyID0gbmV3IERhdGUoKS5nZXRGdWxsWWVhcigpXG4gIGNvbnN0IGRheXMgPSBlYWNoRGF5T2ZJbnRlcnZhbCh7XG4gICAgc3RhcnQ6IG5ldyBEYXRlKHllYXIsIDAsIDEpLFxuICAgIGVuZDogbmV3IERhdGUoeWVhciwgMTEsIDMxKSxcbiAgfSlcblxuICByZXR1cm4gZGF5cy5tYXAoZGF0ZSA9PiAoe1xuICAgIGRhdGU6IGZvcm1hdElTTyhkYXRlLCB7IHJlcHJlc2VudGF0aW9uOiAnZGF0ZScgfSksXG4gICAgY291bnQ6IDAsXG4gICAgbGV2ZWw6IDAsXG4gIH0pKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2VuZXJhdGVUZXN0RGF0YShhcmdzOiB7XG4gIGludGVydmFsPzogeyBzdGFydDogRGF0ZTsgZW5kOiBEYXRlIH1cbiAgbWF4TGV2ZWw/OiBudW1iZXJcbn0pOiBBcnJheTxBY3Rpdml0eT4ge1xuICBjb25zdCBtYXhDb3VudCA9IDIwXG4gIGNvbnN0IG1heExldmVsID0gYXJncy5tYXhMZXZlbCA/IE1hdGgubWF4KDEsIGFyZ3MubWF4TGV2ZWwpIDogNFxuICBjb25zdCBub3cgPSBuZXcgRGF0ZSgpXG5cbiAgY29uc3QgZGF5cyA9IGVhY2hEYXlPZkludGVydmFsKFxuICAgIGFyZ3MuaW50ZXJ2YWwgPz8ge1xuICAgICAgc3RhcnQ6IHN0YXJ0T2ZZZWFyKG5vdyksXG4gICAgICBlbmQ6IGVuZE9mWWVhcihub3cpLFxuICAgIH0sXG4gIClcblxuICByZXR1cm4gZGF5cy5tYXAoZGF0ZSA9PiB7XG4gICAgLy8gVGhlIHJhbmRvbSBhY3Rpdml0eSBjb3VudCBpcyBzaGlmdGVkIGJ5IHVwIHRvIDgwJSB0b3dhcmRzIHplcm8uXG4gICAgY29uc3QgYyA9IE1hdGgucm91bmQoTWF0aC5yYW5kb20oKSAqIG1heENvdW50IC0gTWF0aC5yYW5kb20oKSAqICgwLjggKiBtYXhDb3VudCkpXG4gICAgY29uc3QgY291bnQgPSBNYXRoLm1heCgwLCBjKVxuICAgIGNvbnN0IGxldmVsID0gTWF0aC5jZWlsKChjb3VudCAvIG1heENvdW50KSAqIG1heExldmVsKVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGRhdGU6IGZvcm1hdElTTyhkYXRlLCB7IHJlcHJlc2VudGF0aW9uOiAnZGF0ZScgfSksXG4gICAgICBjb3VudCxcbiAgICAgIGxldmVsLFxuICAgIH1cbiAgfSlcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJhbmdlKG46IG51bWJlcikge1xuICByZXR1cm4gWy4uLkFycmF5KG4pLmtleXMoKV1cbn1cbiIsImltcG9ydCB7IGdldE1vbnRoLCBwYXJzZUlTTyB9IGZyb20gJ2RhdGUtZm5zJ1xuaW1wb3J0IHR5cGUgeyBQcm9wcyB9IGZyb20gJy4uL2NvbXBvbmVudC9BY3Rpdml0eUNhbGVuZGFyJ1xuaW1wb3J0IHsgREVGQVVMVF9NT05USF9MQUJFTFMgfSBmcm9tICcuLi9jb25zdGFudHMnXG5pbXBvcnQgdHlwZSB7IERheUluZGV4LCBEYXlOYW1lLCBXZWVrLCBXZWVrZGF5TGFiZWxzIH0gZnJvbSAnLi4vdHlwZXMnXG5cbmludGVyZmFjZSBNb250aExhYmVsIHtcbiAgd2Vla0luZGV4OiBudW1iZXJcbiAgbGFiZWw6IHN0cmluZ1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0TW9udGhMYWJlbHMoXG4gIHdlZWtzOiBBcnJheTxXZWVrPixcbiAgbW9udGhOYW1lczogQXJyYXk8c3RyaW5nPiA9IERFRkFVTFRfTU9OVEhfTEFCRUxTLFxuKTogQXJyYXk8TW9udGhMYWJlbD4ge1xuICByZXR1cm4gd2Vla3NcbiAgICAucmVkdWNlPEFycmF5PE1vbnRoTGFiZWw+PigobGFiZWxzLCB3ZWVrLCB3ZWVrSW5kZXgpID0+IHtcbiAgICAgIGNvbnN0IGZpcnN0QWN0aXZpdHkgPSB3ZWVrLmZpbmQoYWN0aXZpdHkgPT4gYWN0aXZpdHkgIT09IHVuZGVmaW5lZClcblxuICAgICAgaWYgKCFmaXJzdEFjdGl2aXR5KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5leHBlY3RlZCBlcnJvcjogV2VlayAke3dlZWtJbmRleCArIDF9IGlzIGVtcHR5LmApXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG1vbnRoID0gbW9udGhOYW1lc1tnZXRNb250aChwYXJzZUlTTyhmaXJzdEFjdGl2aXR5LmRhdGUpKV1cblxuICAgICAgaWYgKCFtb250aCkge1xuICAgICAgICBjb25zdCBtb250aE5hbWUgPSBuZXcgRGF0ZShmaXJzdEFjdGl2aXR5LmRhdGUpLnRvTG9jYWxlU3RyaW5nKCdlbi1VUycsIHsgbW9udGg6ICdzaG9ydCcgfSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmV4cGVjdGVkIGVycm9yOiB1bmRlZmluZWQgbW9udGggbGFiZWwgZm9yICR7bW9udGhOYW1lfS5gKVxuICAgICAgfVxuXG4gICAgICBjb25zdCBwcmV2TGFiZWwgPSBsYWJlbHNbbGFiZWxzLmxlbmd0aCAtIDFdXG5cbiAgICAgIGlmICh3ZWVrSW5kZXggPT09IDAgfHwgIXByZXZMYWJlbCB8fCBwcmV2TGFiZWwubGFiZWwgIT09IG1vbnRoKSB7XG4gICAgICAgIHJldHVybiBbLi4ubGFiZWxzLCB7IHdlZWtJbmRleCwgbGFiZWw6IG1vbnRoIH1dXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBsYWJlbHNcbiAgICB9LCBbXSlcbiAgICAuZmlsdGVyKCh7IHdlZWtJbmRleCB9LCBpbmRleCwgbGFiZWxzKSA9PiB7XG4gICAgICAvLyBMYWJlbHMgc2hvdWxkIG9ubHkgYmUgc2hvd24gaWYgdGhlcmUgaXMgXCJlbm91Z2hcIiBzcGFjZSAoZGF0YSkuXG4gICAgICAvLyBUaGlzIGlzIGEgbmFpdmUgaW1wbGVtZW50YXRpb24gdGhhdCBkb2VzIG5vdCB0YWtlIHRoZSBibG9jayBzaXplLFxuICAgICAgLy8gZm9udCBzaXplLCBldGMuIGludG8gYWNjb3VudC5cbiAgICAgIGNvbnN0IG1pbldlZWtzID0gM1xuXG4gICAgICAvLyBTa2lwIHRoZSBmaXJzdCBtb250aCBsYWJlbCBpZiB0aGVyZSBpcyBub3QgZW5vdWdoIHNwYWNlIHRvIHRoZSBuZXh0IG9uZS5cbiAgICAgIGlmIChpbmRleCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gbGFiZWxzWzFdICYmIGxhYmVsc1sxXS53ZWVrSW5kZXggLSB3ZWVrSW5kZXggPj0gbWluV2Vla3NcbiAgICAgIH1cblxuICAgICAgLy8gU2tpcCB0aGUgbGFzdCBtb250aCBsYWJlbCBpZiB0aGVyZSBpcyBub3QgZW5vdWdoIGRhdGEgaW4gdGhhdCBtb250aFxuICAgICAgLy8gdG8gYXZvaWQgb3ZlcmZsb3dpbmcgdGhlIGNhbGVuZGFyIG9uIHRoZSByaWdodC5cbiAgICAgIGlmIChpbmRleCA9PT0gbGFiZWxzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgcmV0dXJuIHdlZWtzLnNsaWNlKHdlZWtJbmRleCkubGVuZ3RoID49IG1pbldlZWtzXG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cnVlXG4gICAgfSlcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1heFdlZWtkYXlMYWJlbFdpZHRoKFxuICBsYWJlbHM6IHN0cmluZ1tdLFxuICBzaG93V2Vla2RheUxhYmVsOiBXZWVrZGF5TGFiZWxzLFxuICBmb250U2l6ZTogbnVtYmVyLFxuKTogbnVtYmVyIHtcbiAgaWYgKGxhYmVscy5sZW5ndGggIT09IDcpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4YWN0bHkgNyBsYWJlbHMsIG9uZSBmb3IgZWFjaCB3ZWVrZGF5IG11c3QgYmUgcGFzc2VkLicpXG4gIH1cblxuICByZXR1cm4gbGFiZWxzLnJlZHVjZShcbiAgICAobWF4V2lkdGgsIGxhYmVsLCBpbmRleCkgPT5cbiAgICAgIHNob3dXZWVrZGF5TGFiZWwuYnlEYXlJbmRleChpbmRleCBhcyBEYXlJbmRleClcbiAgICAgICAgPyBNYXRoLm1heChtYXhXaWR0aCwgTWF0aC5jZWlsKGNhbGNUZXh0RGltZW5zaW9ucyhsYWJlbCwgZm9udFNpemUpLndpZHRoKSlcbiAgICAgICAgOiBtYXhXaWR0aCxcbiAgICAwLFxuICApXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjYWxjVGV4dERpbWVuc2lvbnModGV4dDogc3RyaW5nLCBmb250U2l6ZTogbnVtYmVyKSB7XG4gIGlmICh0eXBlb2YgZG9jdW1lbnQgPT09ICd1bmRlZmluZWQnIHx8IHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIHsgd2lkdGg6IDAsIGhlaWdodDogMCB9XG4gIH1cblxuICBpZiAoZm9udFNpemUgPCAxKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ2ZvbnRTaXplIG11c3QgYmUgcG9zaXRpdmUnKVxuICB9XG5cbiAgaWYgKHRleHQubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIHsgd2lkdGg6IDAsIGhlaWdodDogMCB9XG4gIH1cblxuICBjb25zdCBuYW1lc3BhY2UgPSAnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnXG4gIGNvbnN0IHN2ZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhuYW1lc3BhY2UsICdzdmcnKVxuXG4gIHN2Zy5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSdcbiAgc3ZnLnN0eWxlLnZpc2liaWxpdHkgPSAnaGlkZGVuJ1xuICBzdmcuc3R5bGUuZm9udEZhbWlseSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGRvY3VtZW50LmJvZHkpLmZvbnRGYW1pbHlcbiAgc3ZnLnN0eWxlLmZvbnRTaXplID0gYCR7Zm9udFNpemV9cHhgXG5cbiAgY29uc3QgdGV4dE5vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMobmFtZXNwYWNlLCAndGV4dCcpXG4gIHRleHROb2RlLnRleHRDb250ZW50ID0gdGV4dFxuXG4gIHN2Zy5hcHBlbmRDaGlsZCh0ZXh0Tm9kZSlcbiAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChzdmcpXG4gIGNvbnN0IGJvdW5kaW5nQm94ID0gdGV4dE5vZGUuZ2V0QkJveCgpXG5cbiAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChzdmcpXG5cbiAgcmV0dXJuIHsgd2lkdGg6IGJvdW5kaW5nQm94LndpZHRoLCBoZWlnaHQ6IGJvdW5kaW5nQm94LmhlaWdodCB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpbml0V2Vla2RheUxhYmVscyhcbiAgaW5wdXQ6IFByb3BzWydzaG93V2Vla2RheUxhYmVscyddLFxuICB3ZWVrU3RhcnQ6IERheUluZGV4LFxuKTogV2Vla2RheUxhYmVscyB7XG4gIGlmICghaW5wdXQpXG4gICAgcmV0dXJuIHtcbiAgICAgIGJ5RGF5SW5kZXg6ICgpID0+IGZhbHNlLFxuICAgICAgc2hvdWxkU2hvdzogZmFsc2UsXG4gICAgfVxuXG4gIC8vIERlZmF1bHQ6IFNob3cgZXZlcnkgc2Vjb25kIGRheSBvZiB0aGUgd2Vlay5cbiAgaWYgKGlucHV0ID09PSB0cnVlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGJ5RGF5SW5kZXg6IGluZGV4ID0+IHtcbiAgICAgICAgcmV0dXJuICgoNyArIGluZGV4IC0gd2Vla1N0YXJ0KSAlIDcpICUgMiAhPT0gMFxuICAgICAgfSxcbiAgICAgIHNob3VsZFNob3c6IHRydWUsXG4gICAgfVxuICB9XG5cbiAgY29uc3QgaW5kZXhlZDogQXJyYXk8Ym9vbGVhbj4gPSBbXVxuICBmb3IgKGNvbnN0IG5hbWUgb2YgaW5wdXQpIHtcbiAgICBjb25zdCBpbmRleCA9IGRheU5hbWVUb0luZGV4W25hbWUudG9Mb3dlckNhc2UoKSBhcyBEYXlOYW1lXVxuICAgIGluZGV4ZWRbaW5kZXhdID0gdHJ1ZVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBieURheUluZGV4OiBpbmRleCA9PiBpbmRleGVkW2luZGV4XSA/PyBmYWxzZSxcbiAgICBzaG91bGRTaG93OiBpbnB1dC5sZW5ndGggPiAwLFxuICB9XG59XG5cbmNvbnN0IGRheU5hbWVUb0luZGV4OiB7XG4gIFtuYW1lIGluIERheU5hbWVdOiBEYXlJbmRleFxufSA9IHtcbiAgc3VuOiAwLFxuICBtb246IDEsXG4gIHR1ZTogMixcbiAgd2VkOiAzLFxuICB0aHU6IDQsXG4gIGZyaTogNSxcbiAgc2F0OiA2LFxufVxuIiwiaW1wb3J0IHR5cGUgeyBDb2xvciwgQ29sb3JTY2FsZSwgVGhlbWUsIFRoZW1lSW5wdXQgfSBmcm9tICcuLi90eXBlcydcbmltcG9ydCB7IHJhbmdlIH0gZnJvbSAnLi9jYWxlbmRhcidcblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVRoZW1lKGlucHV0PzogVGhlbWVJbnB1dCwgc3RlcHM6IG51bWJlciA9IDUpOiBUaGVtZSB7XG4gIGNvbnN0IGRlZmF1bHRUaGVtZSA9IGNyZWF0ZURlZmF1bHRUaGVtZShzdGVwcylcblxuICBpZiAoaW5wdXQpIHtcbiAgICB2YWxpZGF0ZUlucHV0KGlucHV0LCBzdGVwcylcblxuICAgIGlucHV0LmxpZ2h0ID0gaW5wdXQubGlnaHQgPz8gZGVmYXVsdFRoZW1lLmxpZ2h0XG4gICAgaW5wdXQuZGFyayA9IGlucHV0LmRhcmsgPz8gZGVmYXVsdFRoZW1lLmRhcmtcblxuICAgIHJldHVybiB7XG4gICAgICBsaWdodDogaXNQYWlyKGlucHV0LmxpZ2h0KSA/IGNhbGNDb2xvclNjYWxlKGlucHV0LmxpZ2h0LCBzdGVwcykgOiBpbnB1dC5saWdodCxcbiAgICAgIGRhcms6IGlzUGFpcihpbnB1dC5kYXJrKSA/IGNhbGNDb2xvclNjYWxlKGlucHV0LmRhcmssIHN0ZXBzKSA6IGlucHV0LmRhcmssXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGRlZmF1bHRUaGVtZVxufVxuXG5mdW5jdGlvbiBjcmVhdGVEZWZhdWx0VGhlbWUoc3RlcHM6IG51bWJlcik6IFRoZW1lIHtcbiAgcmV0dXJuIHtcbiAgICBsaWdodDogY2FsY0NvbG9yU2NhbGUoWydoc2woMCwgMCUsIDkyJSknLCAnaHNsKDAsIDAlLCAyNiUpJ10sIHN0ZXBzKSxcbiAgICBkYXJrOiBjYWxjQ29sb3JTY2FsZShbJ2hzbCgwLCAwJSwgMjIlKScsICdoc2woMCwgMCUsIDkyJSknXSwgc3RlcHMpLFxuICB9XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlSW5wdXQoaW5wdXQ6IFRoZW1lSW5wdXQsIHN0ZXBzOiBudW1iZXIpIHtcbiAgaWYgKHR5cGVvZiBpbnB1dCAhPT0gJ29iamVjdCcgfHwgKGlucHV0LmxpZ2h0ID09PSB1bmRlZmluZWQgJiYgaW5wdXQuZGFyayA9PT0gdW5kZWZpbmVkKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBUaGUgdGhlbWUgb2JqZWN0IG11c3QgY29udGFpbiBhdCBsZWFzdCBvbmUgb2YgdGhlIGZpZWxkcyBcImxpZ2h0XCIgYW5kIFwiZGFya1wiIHdpdGggZXhhY3RseSAyIG9yICR7c3RlcHN9IGNvbG9ycyByZXNwZWN0aXZlbHkuYCxcbiAgICApXG4gIH1cblxuICBpZiAoaW5wdXQubGlnaHQpIHtcbiAgICBjb25zdCB7IGxlbmd0aCB9ID0gaW5wdXQubGlnaHRcbiAgICBpZiAobGVuZ3RoICE9PSAyICYmIGxlbmd0aCAhPT0gc3RlcHMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgdGhlbWUubGlnaHQgbXVzdCBjb250YWluIGV4YWN0bHkgMiBvciAke3N0ZXBzfSBjb2xvcnMsICR7bGVuZ3RofSBwYXNzZWQuYClcbiAgICB9XG5cbiAgICBmb3IgKGNvbnN0IGMgb2YgaW5wdXQubGlnaHQpIHtcbiAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiAhQ1NTLnN1cHBvcnRzKCdjb2xvcicsIGMpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBjb2xvciBcIiR7U3RyaW5nKGMpfVwiIHBhc3NlZC4gQWxsIENTUyBjb2xvciBmb3JtYXRzIGFyZSBhY2NlcHRlZC5gKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChpbnB1dC5kYXJrKSB7XG4gICAgY29uc3QgeyBsZW5ndGggfSA9IGlucHV0LmRhcmtcbiAgICBpZiAobGVuZ3RoICE9PSAyICYmIGxlbmd0aCAhPT0gc3RlcHMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgdGhlbWUuZGFyayBtdXN0IGNvbnRhaW4gZXhhY3RseSAyIG9yICR7c3RlcHN9IGNvbG9ycywgJHtsZW5ndGh9IHBhc3NlZC5gKVxuICAgIH1cblxuICAgIGZvciAoY29uc3QgYyBvZiBpbnB1dC5kYXJrKSB7XG4gICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgIUNTUy5zdXBwb3J0cygnY29sb3InLCBjKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgY29sb3IgXCIke1N0cmluZyhjKX1cIiBwYXNzZWQuIEFsbCBDU1MgY29sb3IgZm9ybWF0cyBhcmUgYWNjZXB0ZWQuYClcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY2FsY0NvbG9yU2NhbGUoW3N0YXJ0LCBlbmRdOiBbQ29sb3IsIENvbG9yXSwgc3RlcHM6IG51bWJlcik6IENvbG9yU2NhbGUge1xuICByZXR1cm4gcmFuZ2Uoc3RlcHMpLm1hcChpID0+IHtcbiAgICAvLyBJbiB0aGUgbG9hZGluZyBhbmltYXRpb24gdGhlIHplcm8gY29sb3IgaXMgdXNlZC5cbiAgICAvLyBIb3dldmVyLCBTYWZhcmkgMTYgY3Jhc2hlcyBpZiBhIENTUyBjb2xvci1taXggZXhwcmVzc2lvbiBsaWtlIGJlbG93IGlzXG4gICAgLy8gY29tYmluZWQgd2l0aCByZWxhdGl2ZSBjb2xvciBzeW50YXggdG8gY2FsY3VsYXRlIGEgaHVlIHZhcmlhdGlvbiBmb3IgdGhlXG4gICAgLy8gYW5pbWF0aW9uLiBTaW5jZSB0aGUgc3RhcnQgYW5kIGVuZCBjb2xvcnMgZG8gbm90IG5lZWQgdG8gYmUgbWl4ZWQsIHRoZXlcbiAgICAvLyBjYW4gYmUgcmV0dXJuZWQgZGlyZWN0bHkgdG8gd29yayBhcm91bmQgdGhpcyBpc3N1ZS5cbiAgICBzd2l0Y2ggKGkpIHtcbiAgICAgIGNhc2UgMDpcbiAgICAgICAgcmV0dXJuIHN0YXJ0XG4gICAgICBjYXNlIHN0ZXBzIC0gMTpcbiAgICAgICAgcmV0dXJuIGVuZFxuICAgICAgZGVmYXVsdDoge1xuICAgICAgICBjb25zdCBwb3MgPSAoaSAvIChzdGVwcyAtIDEpKSAqIDEwMFxuICAgICAgICByZXR1cm4gYGNvbG9yLW1peChpbiBva2xhYiwgJHtlbmR9ICR7cGFyc2VGbG9hdChwb3MudG9GaXhlZCgyKSl9JSwgJHtzdGFydH0pYFxuICAgICAgfVxuICAgIH1cbiAgfSlcbn1cblxuZnVuY3Rpb24gaXNQYWlyPFQ+KHZhbDogVFtdKTogdmFsIGlzIFtULCBUXSB7XG4gIHJldHVybiB2YWwubGVuZ3RoID09PSAyXG59XG4iLCJpbXBvcnQgdHlwZSB7IENTU1Byb3BlcnRpZXMgfSBmcm9tICdyZWFjdCdcblxuZXhwb3J0IGNvbnN0IHN0eWxlcyA9IHtcbiAgY29udGFpbmVyOiAoZm9udFNpemU6IG51bWJlcikgPT5cbiAgICAoe1xuICAgICAgd2lkdGg6ICdtYXgtY29udGVudCcsIC8vIENhbGVuZGFyIHNob3VsZCBub3QgZ3Jvd1xuICAgICAgbWF4V2lkdGg6ICcxMDAlJywgLy8gRG8gbm90IHJlbW92ZSAtIHBhcmVudCBtaWdodCBiZSBhIGZsZXhib3hcbiAgICAgIGRpc3BsYXk6ICdmbGV4JyxcbiAgICAgIGZsZXhEaXJlY3Rpb246ICdjb2x1bW4nLFxuICAgICAgZ2FwOiAnOHB4JyxcbiAgICAgIGZvbnRTaXplOiBgJHtmb250U2l6ZX1weGAsXG4gICAgfSkgc2F0aXNmaWVzIENTU1Byb3BlcnRpZXMsXG4gIHNjcm9sbENvbnRhaW5lcjogKGZvbnRTaXplOiBudW1iZXIpID0+XG4gICAgKHtcbiAgICAgIG1heFdpZHRoOiAnMTAwJScsXG4gICAgICBvdmVyZmxvd1g6ICdhdXRvJyxcbiAgICAgIG92ZXJmbG93WTogJ2hpZGRlbicsXG4gICAgICBwYWRkaW5nVG9wOiBNYXRoLmNlaWwoMC4xICogZm9udFNpemUpLCAvLyBTVkcgPHRleHQ+IG92ZXJmbG93cyBpbiBGaXJlZm94IGF0IHk9MFxuICAgIH0pIHNhdGlzZmllcyBDU1NQcm9wZXJ0aWVzLFxuICBjYWxlbmRhcjoge1xuICAgIGRpc3BsYXk6ICdibG9jaycsIC8vIFNWR3MgYXJlIGlubGluZS1ibG9jayBieSBkZWZhdWx0XG4gICAgb3ZlcmZsb3c6ICd2aXNpYmxlJywgLy8gV2Vla2RheSBsYWJlbHMgYXJlIHJlbmRlcmVkIGxlZnQgb2YgdGhlIGNvbnRhaW5lclxuICB9IHNhdGlzZmllcyBDU1NQcm9wZXJ0aWVzLFxuICByZWN0OiAoY29sb3JTY2hlbWU6ICdsaWdodCcgfCAnZGFyaycpID0+XG4gICAgKHtcbiAgICAgIHN0cm9rZTogY29sb3JTY2hlbWUgPT09ICdsaWdodCcgPyAncmdiYSgwLCAwLCAwLCAwLjA4KScgOiAncmdiYSgyNTUsIDI1NSwgMjU1LCAwLjA0KScsXG4gICAgfSkgc2F0aXNmaWVzIENTU1Byb3BlcnRpZXMsXG4gIGZvb3Rlcjoge1xuICAgIGNvbnRhaW5lcjoge1xuICAgICAgZGlzcGxheTogJ2ZsZXgnLFxuICAgICAgZmxleFdyYXA6ICd3cmFwJyxcbiAgICAgIGdhcDogJzRweCAxNnB4JyxcbiAgICAgIHdoaXRlU3BhY2U6ICdub3dyYXAnLFxuICAgIH0gc2F0aXNmaWVzIENTU1Byb3BlcnRpZXMsXG4gICAgbGVnZW5kOiB7XG4gICAgICBtYXJnaW5MZWZ0OiAnYXV0bycsXG4gICAgICBkaXNwbGF5OiAnZmxleCcsXG4gICAgICBhbGlnbkl0ZW1zOiAnY2VudGVyJyxcbiAgICAgIGdhcDogJzNweCcsXG4gICAgfSBzYXRpc2ZpZXMgQ1NTUHJvcGVydGllcyxcbiAgfSxcbn1cbiIsIid1c2UgY2xpZW50J1xuXG5pbXBvcnQge1xuICBmb3J3YXJkUmVmLFxuICBGcmFnbWVudCxcbiAgdXNlRWZmZWN0LFxuICB1c2VTdGF0ZSxcbiAgdHlwZSBDU1NQcm9wZXJ0aWVzLFxuICB0eXBlIEZvcndhcmRlZFJlZixcbiAgdHlwZSBSZWFjdEVsZW1lbnQsXG59IGZyb20gJ3JlYWN0J1xuaW1wb3J0IHsgZ2V0WWVhciwgcGFyc2VJU08gfSBmcm9tICdkYXRlLWZucydcbmltcG9ydCB7IERFRkFVTFRfTEFCRUxTLCBMQUJFTF9NQVJHSU4sIE5BTUVTUEFDRSB9IGZyb20gJy4uL2NvbnN0YW50cydcbmltcG9ydCB7IHVzZUNvbG9yU2NoZW1lIH0gZnJvbSAnLi4vaG9va3MvdXNlQ29sb3JTY2hlbWUnXG5pbXBvcnQgeyBsb2FkaW5nQW5pbWF0aW9uTmFtZSwgdXNlTG9hZGluZ0FuaW1hdGlvbiB9IGZyb20gJy4uL2hvb2tzL3VzZUxvYWRpbmdBbmltYXRpb24nXG5pbXBvcnQgeyB1c2VQcmVmZXJzUmVkdWNlZE1vdGlvbiB9IGZyb20gJy4uL2hvb2tzL3VzZVByZWZlcnNSZWR1Y2VkTW90aW9uJ1xuaW1wb3J0IHtcbiAgZ2VuZXJhdGVFbXB0eURhdGEsXG4gIGdldENsYXNzTmFtZSxcbiAgZ3JvdXBCeVdlZWtzLFxuICByYW5nZSxcbiAgdmFsaWRhdGVBY3Rpdml0aWVzLFxufSBmcm9tICcuLi9saWIvY2FsZW5kYXInXG5pbXBvcnQgeyBnZXRNb250aExhYmVscywgaW5pdFdlZWtkYXlMYWJlbHMsIG1heFdlZWtkYXlMYWJlbFdpZHRoIH0gZnJvbSAnLi4vbGliL2xhYmVsJ1xuaW1wb3J0IHsgY3JlYXRlVGhlbWUgfSBmcm9tICcuLi9saWIvdGhlbWUnXG5pbXBvcnQgdHlwZSB7XG4gIEFjdGl2aXR5LFxuICBCbG9ja0VsZW1lbnQsXG4gIERheUluZGV4LFxuICBEYXlOYW1lLFxuICBFdmVudEhhbmRsZXJNYXAsXG4gIExhYmVscyxcbiAgUmVhY3RFdmVudCxcbiAgU1ZHUmVjdEV2ZW50SGFuZGxlcixcbiAgVGhlbWVJbnB1dCxcbn0gZnJvbSAnLi4vdHlwZXMnXG5pbXBvcnQgeyBzdHlsZXMgfSBmcm9tICcuL3N0eWxlcydcblxuZXhwb3J0IGludGVyZmFjZSBQcm9wcyB7XG4gIC8qKlxuICAgKiBMaXN0IG9mIGNhbGVuZGFyIGVudHJpZXMuIEV2ZXJ5IGBBY3Rpdml0eWAgb2JqZWN0IHJlcXVpcmVzIGFuIElTTyA4NjAxXG4gICAqIGBkYXRlYCBzdHJpbmcgaW4gdGhlIGZvcm1hdCBgeXl5eS1NTS1kZGAsIGEgYGNvdW50YCBwcm9wZXJ0eSB3aXRoIHRoZVxuICAgKiBhbW91bnQgb2YgdHJhY2tlZCBkYXRhIGFuZCBhIGBsZXZlbGAgcHJvcGVydHkgaW4gdGhlIHJhbmdlIGAwLW1heExldmVsYFxuICAgKiB0byBzcGVjaWZ5IGFjdGl2aXR5IGludGVuc2l0eS4gVGhlIGBtYXhMZXZlbGAgcHJvcCBpcyA0IGJ5IGRlZmF1bHQuXG4gICAqXG4gICAqIEZvciBtaXNzaW5nIGRhdGVzLCBubyBhY3Rpdml0eSBpcyBhc3N1bWVkLiBUaGlzIGFsbG93cyBjaG9vc2luZyB0aGUgc3RhcnRcbiAgICogYW5kIGVuZCBkYXRlIG9mIHRoZSBjYWxlbmRhciBhcmJpdHJhcmlseSBieSBwYXNzaW5nIGVtcHR5IGVudHJpZXMgYXMgdGhlXG4gICAqIGZpcnN0IGFuZCBsYXN0IGl0ZW0uXG4gICAqXG4gICAqIEV4YW1wbGUgb2JqZWN0OlxuICAgKlxuICAgKiBgYGBqc29uXG4gICAqIHtcbiAgICogICBkYXRlOiBcIjIwMjEtMDItMjBcIixcbiAgICogICBjb3VudDogMTYsXG4gICAqICAgbGV2ZWw6IDNcbiAgICogfVxuICAgKiBgYGBcbiAgICovXG4gIGRhdGE6IEFycmF5PEFjdGl2aXR5PlxuICAvKipcbiAgICogTWFyZ2luIGJldHdlZW4gYmxvY2tzIGluIHBpeGVscy5cbiAgICovXG4gIGJsb2NrTWFyZ2luPzogbnVtYmVyXG4gIC8qKlxuICAgKiBCb3JkZXIgcmFkaXVzIG9mIGJsb2NrcyBpbiBwaXhlbHMuXG4gICAqL1xuICBibG9ja1JhZGl1cz86IG51bWJlclxuICAvKipcbiAgICogQmxvY2sgc2l6ZSBpbiBwaXhlbHMuXG4gICAqL1xuICBibG9ja1NpemU/OiBudW1iZXJcbiAgLyoqXG4gICAqIFVzZSBhIHNwZWNpZmljIGNvbG9yIHNjaGVtZSBpbnN0ZWFkIG9mIHRoZSBzeXN0ZW0gb25lLiBTdXBwb3J0ZWQgdmFsdWVzXG4gICAqIGFyZSBgJ2xpZ2h0J2AgYW5kIGAnZGFyaydgLlxuICAgKi9cbiAgY29sb3JTY2hlbWU/OiAnbGlnaHQnIHwgJ2RhcmsnXG4gIC8qKlxuICAgKiBFdmVudCBoYW5kbGVycyB0byByZWdpc3RlciBmb3IgdGhlIFNWRyBgPHJlY3Q+YCBlbGVtZW50cyB0aGF0IGFyZSB1c2VkIHRvXG4gICAqIHJlbmRlciB0aGUgY2FsZW5kYXIgZGF5cy4gSGFuZGxlciBzaWduYXR1cmU6IGBldmVudCA9PiBhY3Rpdml0eSA9PiB2b2lkYFxuICAgKi9cbiAgZXZlbnRIYW5kbGVycz86IEV2ZW50SGFuZGxlck1hcFxuICAvKipcbiAgICogRm9udCBzaXplIGZvciB0ZXh0IGluIHBpeGVscy5cbiAgICovXG4gIGZvbnRTaXplPzogbnVtYmVyXG4gIC8qKlxuICAgKiBUb2dnbGUgdG8gaGlkZSBjb2xvciBsZWdlbmQgYmVsb3cgY2FsZW5kYXIuXG4gICAqL1xuICBoaWRlQ29sb3JMZWdlbmQ/OiBib29sZWFuXG4gIC8qKlxuICAgKiBUb2dnbGUgdG8gaGlkZSBtb250aCBsYWJlbHMgYWJvdmUgY2FsZW5kYXIuXG4gICAqL1xuICBoaWRlTW9udGhMYWJlbHM/OiBib29sZWFuXG4gIC8qKlxuICAgKiBUb2dnbGUgdG8gaGlkZSB0aGUgdG90YWwgY291bnQgYmVsb3cgY2FsZW5kYXIuXG4gICAqL1xuICBoaWRlVG90YWxDb3VudD86IGJvb2xlYW5cbiAgLyoqXG4gICAqIExvY2FsaXphdGlvbiBzdHJpbmdzIGZvciBhbGwgY2FsZW5kYXIgbGFiZWxzLlxuICAgKlxuICAgKiBgdG90YWxDb3VudGAgc3VwcG9ydHMgdGhlIHBsYWNlaG9sZGVycyBge3tjb3VudH19YCBhbmQgYHt7eWVhcn19YC5cbiAgICovXG4gIGxhYmVscz86IExhYmVsc1xuICAvKipcbiAgICogTWF4aW11bSBhY3Rpdml0eSBsZXZlbCAoemVybyBpbmRleGVkKS5cbiAgICovXG4gIG1heExldmVsPzogbnVtYmVyXG4gIC8qKlxuICAgKiBUb2dnbGUgZm9yIGxvYWRpbmcgc3RhdGUuIGBkYXRhYCBwcm9wZXJ0eSB3aWxsIGJlIGlnbm9yZWQgaWYgc2V0LlxuICAgKi9cbiAgbG9hZGluZz86IGJvb2xlYW5cbiAgLyoqXG4gICAqIFJlZiB0byBhY2Nlc3MgdGhlIGNhbGVuZGFyIERPTSBub2RlLlxuICAgKi9cbiAgcmVmPzogRm9yd2FyZGVkUmVmPEhUTUxFbGVtZW50PlxuICAvKipcbiAgICogUmVuZGVyIHByb3AgZm9yIGNhbGVuZGFyIGJsb2NrcyAoYWN0aXZpdGllcykuIEZvciBleGFtcGxlLCB1c2VmdWwgdG8gd3JhcFxuICAgKiB0aGUgZWxlbWVudCB3aXRoIGEgdG9vbHRpcCBjb21wb25lbnQuIFVzZSBgUmVhY3QuY2xvbmVFbGVtZW50YCB0byBwYXNzXG4gICAqIGFkZGl0aW9uYWwgcHJvcHMgdG8gdGhlIGVsZW1lbnQgaWYgbmVjZXNzYXJ5LlxuICAgKi9cbiAgcmVuZGVyQmxvY2s/OiAoYmxvY2s6IEJsb2NrRWxlbWVudCwgYWN0aXZpdHk6IEFjdGl2aXR5KSA9PiBSZWFjdEVsZW1lbnRcbiAgLyoqXG4gICAqIFJlbmRlciBwcm9wIGZvciBjb2xvciBsZWdlbmQgYmxvY2tzLiBGb3IgZXhhbXBsZSwgdXNlZnVsIHRvIHdyYXAgdGhlXG4gICAqIGVsZW1lbnQgd2l0aCBhIHRvb2x0aXAgY29tcG9uZW50LiBVc2UgYFJlYWN0LmNsb25lRWxlbWVudGAgdG8gcGFzc1xuICAgKiBhZGRpdGlvbmFsIHByb3BzIHRvIHRoZSBlbGVtZW50IGlmIG5lY2Vzc2FyeS5cbiAgICovXG4gIHJlbmRlckNvbG9yTGVnZW5kPzogKGJsb2NrOiBCbG9ja0VsZW1lbnQsIGxldmVsOiBudW1iZXIpID0+IFJlYWN0RWxlbWVudFxuICAvKipcbiAgICogVG9nZ2xlIHRvIHNob3cgd2Vla2RheSBsYWJlbHMgbGVmdCB0byB0aGUgY2FsZW5kYXIuXG4gICAqIEFsdGVybmF0aXZlbHksIHBhc3MgYSBsaXN0IG9mIElTTyA4NjAxIHdlZWtkYXkgbmFtZXMgdG8gc2hvdy5cbiAgICogRm9yIGV4YW1wbGUgYFsnbW9uJywgJ3dlZCcsICdmcmknXWAuXG4gICAqL1xuICBzaG93V2Vla2RheUxhYmVscz86IGJvb2xlYW4gfCBBcnJheTxEYXlOYW1lPlxuICAvKipcbiAgICogU3R5bGUgb2JqZWN0IHRvIHBhc3MgdG8gY29tcG9uZW50IGNvbnRhaW5lci5cbiAgICovXG4gIHN0eWxlPzogQ1NTUHJvcGVydGllc1xuICAvKipcbiAgICogU2V0IHRoZSBjYWxlbmRhciBjb2xvcnMgZm9yIHRoZSBsaWdodCBhbmQgZGFyayBzeXN0ZW0gY29sb3Igc2NoZW1lLlxuICAgKiBEZWZpbmUgZWFjaCBjb2xvciBzY2FsZSBleHBsaWNpdGx5IGJ5IHNldHRpbmdzIGFsbCBjb2xvcnMgKDUgcGVyIGRlZmF1bHQpXG4gICAqIG9yIHBhc3MgZXhhY3RseSB0d28gY29sb3JzICh0aGUgbG93ZXN0IGFuZCBoaWdoZXN0IGludGVuc2l0eSkgdG8gY2FsY3VsYXRlXG4gICAqIGEgc2luZ2xlLWh1ZSBzY2FsZS4gQ29sb3JzIGNhbiBiZSBzcGVjaWZpZWQgaW4gYW55IHZhbGlkIENTUyBmb3JtYXQuXG4gICAqXG4gICAqIFRoZSBjb2xvcnMgZm9yIGF0IGxlYXN0IG9uZSBzY2hlbWUgbXVzdCBiZSBzZXQuIElmIHVuZGVmaW5lZCwgdGhlIGRlZmF1bHRcbiAgICogdGhlbWUgaXMgdXNlZC4gQnkgZGVmYXVsdCwgdGhlIGNhbGVuZGFyIHdpbGwgc2VsZWN0IHRoZSBjdXJyZW50IHN5c3RlbSBjb2xvclxuICAgKiBzY2hlbWUsIGJ1dCB5b3UgY2FuIGVuZm9yY2UgYSBzcGVjaWZpYyBzY2hlbWUgd2l0aCB0aGUgYGNvbG9yU2NoZW1lYCBwcm9wLlxuICAgKlxuICAgKiBFeGFtcGxlOlxuICAgKlxuICAgKiBgYGB0c3hcbiAgICogPEFjdGl2aXR5Q2FsZW5kYXJcbiAgICogICBkYXRhPXtkYXRhfVxuICAgKiAgIHRoZW1lPXt7XG4gICAqICAgICBsaWdodDogWydoc2woMCwgMCUsIDkyJSknLCAnZmlyZWJyaWNrJ10sXG4gICAqICAgICBkYXJrOiBbJyMzMzMnLCAncmdiKDIxNCwgMTYsIDE3NCknXSxcbiAgICogICB9fVxuICAgKiAvPlxuICAgKiBgYGBcbiAgICpcbiAgICovXG4gIHRoZW1lPzogVGhlbWVJbnB1dFxuICAvKipcbiAgICogT3ZlcndyaXRlIHRoZSB0b3RhbCBhY3Rpdml0eSBjb3VudC5cbiAgICovXG4gIHRvdGFsQ291bnQ/OiBudW1iZXJcbiAgLyoqXG4gICAqIEluZGV4IG9mIGRheSB0byBiZSB1c2VkIGFzIHN0YXJ0IG9mIHdlZWsuIDAgcmVwcmVzZW50cyBTdW5kYXkuXG4gICAqL1xuICB3ZWVrU3RhcnQ/OiBEYXlJbmRleFxufVxuXG5leHBvcnQgY29uc3QgQWN0aXZpdHlDYWxlbmRhciA9IGZvcndhcmRSZWY8SFRNTEVsZW1lbnQsIFByb3BzPihcbiAgKFxuICAgIHtcbiAgICAgIGRhdGE6IGFjdGl2aXRpZXMsXG4gICAgICBibG9ja01hcmdpbiA9IDQsXG4gICAgICBibG9ja1JhZGl1cyA9IDIsXG4gICAgICBibG9ja1NpemUgPSAxMixcbiAgICAgIGNvbG9yU2NoZW1lOiBjb2xvclNjaGVtZVByb3AgPSB1bmRlZmluZWQsXG4gICAgICBldmVudEhhbmRsZXJzID0ge30sXG4gICAgICBmb250U2l6ZSA9IDE0LFxuICAgICAgaGlkZUNvbG9yTGVnZW5kID0gZmFsc2UsXG4gICAgICBoaWRlTW9udGhMYWJlbHMgPSBmYWxzZSxcbiAgICAgIGhpZGVUb3RhbENvdW50ID0gZmFsc2UsXG4gICAgICBsYWJlbHM6IGxhYmVsc1Byb3AgPSB1bmRlZmluZWQsXG4gICAgICBtYXhMZXZlbCA9IDQsXG4gICAgICBsb2FkaW5nID0gZmFsc2UsXG4gICAgICByZW5kZXJCbG9jayA9IHVuZGVmaW5lZCxcbiAgICAgIHJlbmRlckNvbG9yTGVnZW5kID0gdW5kZWZpbmVkLFxuICAgICAgc2hvd1dlZWtkYXlMYWJlbHMgPSBmYWxzZSxcbiAgICAgIHN0eWxlOiBzdHlsZVByb3AgPSB7fSxcbiAgICAgIHRoZW1lOiB0aGVtZVByb3AgPSB1bmRlZmluZWQsXG4gICAgICB0b3RhbENvdW50OiB0b3RhbENvdW50UHJvcCA9IHVuZGVmaW5lZCxcbiAgICAgIHdlZWtTdGFydCA9IDAsIC8vIFN1bmRheVxuICAgIH06IFByb3BzLCAvLyBSZXF1aXJlZCBmb3IgcmVhY3QtZG9jZ2VuXG4gICAgcmVmLFxuICApID0+IHtcbiAgICBjb25zdCBbaXNDbGllbnQsIHNldElzQ2xpZW50XSA9IHVzZVN0YXRlKGZhbHNlKVxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICBzZXRJc0NsaWVudCh0cnVlKVxuICAgIH0sIFtdKVxuXG4gICAgbWF4TGV2ZWwgPSBNYXRoLm1heCgxLCBtYXhMZXZlbClcblxuICAgIGNvbnN0IHRoZW1lID0gY3JlYXRlVGhlbWUodGhlbWVQcm9wLCBtYXhMZXZlbCArIDEpXG4gICAgY29uc3Qgc3lzdGVtQ29sb3JTY2hlbWUgPSB1c2VDb2xvclNjaGVtZSgpXG4gICAgY29uc3QgY29sb3JTY2hlbWUgPSBjb2xvclNjaGVtZVByb3AgPz8gc3lzdGVtQ29sb3JTY2hlbWVcbiAgICBjb25zdCBjb2xvclNjYWxlID0gdGhlbWVbY29sb3JTY2hlbWVdXG5cbiAgICB1c2VMb2FkaW5nQW5pbWF0aW9uKGNvbG9yU2NhbGVbMF0gYXMgc3RyaW5nLCBjb2xvclNjaGVtZSlcbiAgICBjb25zdCB1c2VBbmltYXRpb24gPSAhdXNlUHJlZmVyc1JlZHVjZWRNb3Rpb24oKVxuXG4gICAgaWYgKGxvYWRpbmcpIHtcbiAgICAgIGFjdGl2aXRpZXMgPSBnZW5lcmF0ZUVtcHR5RGF0YSgpXG4gICAgfVxuXG4gICAgdmFsaWRhdGVBY3Rpdml0aWVzKGFjdGl2aXRpZXMsIG1heExldmVsKVxuXG4gICAgY29uc3QgZmlyc3RBY3Rpdml0eSA9IGFjdGl2aXRpZXNbMF0gYXMgQWN0aXZpdHlcbiAgICBjb25zdCB5ZWFyID0gZ2V0WWVhcihwYXJzZUlTTyhmaXJzdEFjdGl2aXR5LmRhdGUpKVxuICAgIGNvbnN0IHdlZWtzID0gZ3JvdXBCeVdlZWtzKGFjdGl2aXRpZXMsIHdlZWtTdGFydClcblxuICAgIGNvbnN0IGxhYmVscyA9IE9iamVjdC5hc3NpZ24oe30sIERFRkFVTFRfTEFCRUxTLCBsYWJlbHNQcm9wKVxuICAgIGNvbnN0IGxhYmVsSGVpZ2h0ID0gaGlkZU1vbnRoTGFiZWxzID8gMCA6IGZvbnRTaXplICsgTEFCRUxfTUFSR0lOXG5cbiAgICBjb25zdCB3ZWVrZGF5TGFiZWxzID0gaW5pdFdlZWtkYXlMYWJlbHMoc2hvd1dlZWtkYXlMYWJlbHMsIHdlZWtTdGFydClcblxuICAgIC8vIE11c3QgYmUgY2FsY3VsYXRlZCBvbiB0aGUgY2xpZW50IG9yIFNTUiBoeWRyYXRpb24gZXJyb3JzIHdpbGwgb2NjdXJcbiAgICAvLyBiZWNhdXNlIHNlcnZlciBhbmQgY2xpZW50IEhUTUwgd291bGQgbm90IG1hdGNoLlxuICAgIGNvbnN0IHdlZWtkYXlMYWJlbE9mZnNldCA9XG4gICAgICBpc0NsaWVudCAmJiB3ZWVrZGF5TGFiZWxzLnNob3VsZFNob3dcbiAgICAgICAgPyBtYXhXZWVrZGF5TGFiZWxXaWR0aChsYWJlbHMud2Vla2RheXMsIHdlZWtkYXlMYWJlbHMsIGZvbnRTaXplKSArIExBQkVMX01BUkdJTlxuICAgICAgICA6IHVuZGVmaW5lZFxuXG4gICAgZnVuY3Rpb24gZ2V0RGltZW5zaW9ucygpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHdpZHRoOiB3ZWVrcy5sZW5ndGggKiAoYmxvY2tTaXplICsgYmxvY2tNYXJnaW4pIC0gYmxvY2tNYXJnaW4sXG4gICAgICAgIGhlaWdodDogbGFiZWxIZWlnaHQgKyAoYmxvY2tTaXplICsgYmxvY2tNYXJnaW4pICogNyAtIGJsb2NrTWFyZ2luLFxuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldEV2ZW50SGFuZGxlcnMoYWN0aXZpdHk6IEFjdGl2aXR5KTogU1ZHUmVjdEV2ZW50SGFuZGxlciB7XG4gICAgICByZXR1cm4gKFxuICAgICAgICBPYmplY3Qua2V5cyhldmVudEhhbmRsZXJzKSBhcyBBcnJheTxrZXlvZiBTVkdSZWN0RXZlbnRIYW5kbGVyPlxuICAgICAgKS5yZWR1Y2U8U1ZHUmVjdEV2ZW50SGFuZGxlcj4oXG4gICAgICAgIChoYW5kbGVycywga2V5KSA9PiAoe1xuICAgICAgICAgIC4uLmhhbmRsZXJzLFxuICAgICAgICAgIFtrZXldOiAoZXZlbnQ6IFJlYWN0RXZlbnQ8U1ZHUmVjdEVsZW1lbnQ+KSA9PiBldmVudEhhbmRsZXJzW2tleV0/LihldmVudCkoYWN0aXZpdHkpLFxuICAgICAgICB9KSxcbiAgICAgICAge30sXG4gICAgICApXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVuZGVyQ2FsZW5kYXIoKSB7XG4gICAgICByZXR1cm4gd2Vla3NcbiAgICAgICAgLm1hcCgod2Vlaywgd2Vla0luZGV4KSA9PlxuICAgICAgICAgIHdlZWsubWFwKChhY3Rpdml0eSwgZGF5SW5kZXgpID0+IHtcbiAgICAgICAgICAgIGlmICghYWN0aXZpdHkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgbG9hZGluZ0FuaW1hdGlvbiA9XG4gICAgICAgICAgICAgIGxvYWRpbmcgJiYgdXNlQW5pbWF0aW9uXG4gICAgICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgICAgIGFuaW1hdGlvbjogYCR7bG9hZGluZ0FuaW1hdGlvbk5hbWV9IDEuNzVzIGVhc2UtaW4tb3V0IGluZmluaXRlYCxcbiAgICAgICAgICAgICAgICAgICAgYW5pbWF0aW9uRGVsYXk6IGAke3dlZWtJbmRleCAqIDIwICsgZGF5SW5kZXggKiAyMH1tc2AsXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWRcblxuICAgICAgICAgICAgY29uc3QgYmxvY2sgPSAoXG4gICAgICAgICAgICAgIDxyZWN0XG4gICAgICAgICAgICAgICAgey4uLmdldEV2ZW50SGFuZGxlcnMoYWN0aXZpdHkpfVxuICAgICAgICAgICAgICAgIHg9ezB9XG4gICAgICAgICAgICAgICAgeT17bGFiZWxIZWlnaHQgKyAoYmxvY2tTaXplICsgYmxvY2tNYXJnaW4pICogZGF5SW5kZXh9XG4gICAgICAgICAgICAgICAgd2lkdGg9e2Jsb2NrU2l6ZX1cbiAgICAgICAgICAgICAgICBoZWlnaHQ9e2Jsb2NrU2l6ZX1cbiAgICAgICAgICAgICAgICByeD17YmxvY2tSYWRpdXN9XG4gICAgICAgICAgICAgICAgcnk9e2Jsb2NrUmFkaXVzfVxuICAgICAgICAgICAgICAgIGZpbGw9e2NvbG9yU2NhbGVbYWN0aXZpdHkubGV2ZWxdfVxuICAgICAgICAgICAgICAgIGRhdGEtZGF0ZT17YWN0aXZpdHkuZGF0ZX1cbiAgICAgICAgICAgICAgICBkYXRhLWxldmVsPXthY3Rpdml0eS5sZXZlbH1cbiAgICAgICAgICAgICAgICBzdHlsZT17eyAuLi5zdHlsZXMucmVjdChjb2xvclNjaGVtZSksIC4uLmxvYWRpbmdBbmltYXRpb24gfX1cbiAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgIClcblxuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgPEZyYWdtZW50IGtleT17YWN0aXZpdHkuZGF0ZX0+XG4gICAgICAgICAgICAgICAge3JlbmRlckJsb2NrID8gcmVuZGVyQmxvY2soYmxvY2ssIGFjdGl2aXR5KSA6IGJsb2NrfVxuICAgICAgICAgICAgICA8L0ZyYWdtZW50PlxuICAgICAgICAgICAgKVxuICAgICAgICAgIH0pLFxuICAgICAgICApXG4gICAgICAgIC5tYXAoKHdlZWssIHgpID0+IChcbiAgICAgICAgICA8ZyBrZXk9e3h9IHRyYW5zZm9ybT17YHRyYW5zbGF0ZSgkeyhibG9ja1NpemUgKyBibG9ja01hcmdpbikgKiB4fSwgMClgfT5cbiAgICAgICAgICAgIHt3ZWVrfVxuICAgICAgICAgIDwvZz5cbiAgICAgICAgKSlcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZW5kZXJGb290ZXIoKSB7XG4gICAgICBpZiAoaGlkZVRvdGFsQ291bnQgJiYgaGlkZUNvbG9yTGVnZW5kKSB7XG4gICAgICAgIHJldHVybiBudWxsXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHRvdGFsQ291bnQgPVxuICAgICAgICB0eXBlb2YgdG90YWxDb3VudFByb3AgPT09ICdudW1iZXInXG4gICAgICAgICAgPyB0b3RhbENvdW50UHJvcFxuICAgICAgICAgIDogYWN0aXZpdGllcy5yZWR1Y2UoKHN1bSwgYWN0aXZpdHkpID0+IHN1bSArIGFjdGl2aXR5LmNvdW50LCAwKVxuXG4gICAgICByZXR1cm4gKFxuICAgICAgICA8Zm9vdGVyXG4gICAgICAgICAgY2xhc3NOYW1lPXtnZXRDbGFzc05hbWUoJ2Zvb3RlcicpfVxuICAgICAgICAgIHN0eWxlPXt7IC4uLnN0eWxlcy5mb290ZXIuY29udGFpbmVyLCBtYXJnaW5MZWZ0OiB3ZWVrZGF5TGFiZWxPZmZzZXQgfX1cbiAgICAgICAgPlxuICAgICAgICAgIHsvKiBQbGFjZWhvbGRlciAqL31cbiAgICAgICAgICB7bG9hZGluZyAmJiA8ZGl2PiZuYnNwOzwvZGl2Pn1cblxuICAgICAgICAgIHshbG9hZGluZyAmJiAhaGlkZVRvdGFsQ291bnQgJiYgKFxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e2dldENsYXNzTmFtZSgnY291bnQnKX0+XG4gICAgICAgICAgICAgIHtsYWJlbHMudG90YWxDb3VudFxuICAgICAgICAgICAgICAgID8gbGFiZWxzLnRvdGFsQ291bnRcbiAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoJ3t7Y291bnR9fScsIFN0cmluZyh0b3RhbENvdW50KSlcbiAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoJ3t7eWVhcn19JywgU3RyaW5nKHllYXIpKVxuICAgICAgICAgICAgICAgIDogYCR7dG90YWxDb3VudH0gYWN0aXZpdGllcyBpbiAke3llYXJ9YH1cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICl9XG5cbiAgICAgICAgICB7IWxvYWRpbmcgJiYgIWhpZGVDb2xvckxlZ2VuZCAmJiAoXG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17Z2V0Q2xhc3NOYW1lKCdsZWdlbmQtY29sb3JzJyl9IHN0eWxlPXtzdHlsZXMuZm9vdGVyLmxlZ2VuZH0+XG4gICAgICAgICAgICAgIDxzcGFuIHN0eWxlPXt7IG1hcmdpblJpZ2h0OiAnMC40ZW0nIH19PntsYWJlbHMubGVnZW5kLmxlc3N9PC9zcGFuPlxuICAgICAgICAgICAgICB7cmFuZ2UobWF4TGV2ZWwgKyAxKS5tYXAobGV2ZWwgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGJsb2NrID0gKFxuICAgICAgICAgICAgICAgICAgPHN2ZyB3aWR0aD17YmxvY2tTaXplfSBoZWlnaHQ9e2Jsb2NrU2l6ZX0ga2V5PXtsZXZlbH0+XG4gICAgICAgICAgICAgICAgICAgIDxyZWN0XG4gICAgICAgICAgICAgICAgICAgICAgd2lkdGg9e2Jsb2NrU2l6ZX1cbiAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ9e2Jsb2NrU2l6ZX1cbiAgICAgICAgICAgICAgICAgICAgICBmaWxsPXtjb2xvclNjYWxlW2xldmVsXX1cbiAgICAgICAgICAgICAgICAgICAgICByeD17YmxvY2tSYWRpdXN9XG4gICAgICAgICAgICAgICAgICAgICAgcnk9e2Jsb2NrUmFkaXVzfVxuICAgICAgICAgICAgICAgICAgICAgIHN0eWxlPXtzdHlsZXMucmVjdChjb2xvclNjaGVtZSl9XG4gICAgICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgICAgICA8L3N2Zz5cbiAgICAgICAgICAgICAgICApXG5cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVuZGVyQ29sb3JMZWdlbmQgPyByZW5kZXJDb2xvckxlZ2VuZChibG9jaywgbGV2ZWwpIDogYmxvY2tcbiAgICAgICAgICAgICAgfSl9XG4gICAgICAgICAgICAgIDxzcGFuIHN0eWxlPXt7IG1hcmdpbkxlZnQ6ICcwLjRlbScgfX0+e2xhYmVscy5sZWdlbmQubW9yZX08L3NwYW4+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICApfVxuICAgICAgICA8L2Zvb3Rlcj5cbiAgICAgIClcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZW5kZXJXZWVrZGF5TGFiZWxzKCkge1xuICAgICAgaWYgKCF3ZWVrZGF5TGFiZWxzLnNob3VsZFNob3cpIHtcbiAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIChcbiAgICAgICAgPGcgY2xhc3NOYW1lPXtnZXRDbGFzc05hbWUoJ2xlZ2VuZC13ZWVrZGF5Jyl9PlxuICAgICAgICAgIHtyYW5nZSg3KS5tYXAoaW5kZXggPT4ge1xuICAgICAgICAgICAgY29uc3QgZGF5SW5kZXggPSAoKGluZGV4ICsgd2Vla1N0YXJ0KSAlIDcpIGFzIERheUluZGV4XG5cbiAgICAgICAgICAgIGlmICghd2Vla2RheUxhYmVscy5ieURheUluZGV4KGRheUluZGV4KSkge1xuICAgICAgICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICA8dGV4dFxuICAgICAgICAgICAgICAgIHg9ey1MQUJFTF9NQVJHSU59XG4gICAgICAgICAgICAgICAgeT17bGFiZWxIZWlnaHQgKyAoYmxvY2tTaXplICsgYmxvY2tNYXJnaW4pICogaW5kZXggKyBibG9ja1NpemUgLyAyfVxuICAgICAgICAgICAgICAgIGRvbWluYW50QmFzZWxpbmU9XCJjZW50cmFsXCJcbiAgICAgICAgICAgICAgICB0ZXh0QW5jaG9yPVwiZW5kXCJcbiAgICAgICAgICAgICAgICBmaWxsPVwiY3VycmVudENvbG9yXCJcbiAgICAgICAgICAgICAgICBrZXk9e2luZGV4fVxuICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAge2xhYmVscy53ZWVrZGF5c1tkYXlJbmRleF19XG4gICAgICAgICAgICAgIDwvdGV4dD5cbiAgICAgICAgICAgIClcbiAgICAgICAgICB9KX1cbiAgICAgICAgPC9nPlxuICAgICAgKVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlbmRlck1vbnRoTGFiZWxzKCkge1xuICAgICAgaWYgKGhpZGVNb250aExhYmVscykge1xuICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgfVxuXG4gICAgICByZXR1cm4gKFxuICAgICAgICA8ZyBjbGFzc05hbWU9e2dldENsYXNzTmFtZSgnbGVnZW5kLW1vbnRoJyl9PlxuICAgICAgICAgIHtnZXRNb250aExhYmVscyh3ZWVrcywgbGFiZWxzLm1vbnRocykubWFwKCh7IGxhYmVsLCB3ZWVrSW5kZXggfSkgPT4gKFxuICAgICAgICAgICAgPHRleHRcbiAgICAgICAgICAgICAgeD17KGJsb2NrU2l6ZSArIGJsb2NrTWFyZ2luKSAqIHdlZWtJbmRleH1cbiAgICAgICAgICAgICAgeT17MH1cbiAgICAgICAgICAgICAgZG9taW5hbnRCYXNlbGluZT1cImhhbmdpbmdcIlxuICAgICAgICAgICAgICBmaWxsPVwiY3VycmVudENvbG9yXCJcbiAgICAgICAgICAgICAga2V5PXt3ZWVrSW5kZXh9XG4gICAgICAgICAgICA+XG4gICAgICAgICAgICAgIHtsYWJlbH1cbiAgICAgICAgICAgIDwvdGV4dD5cbiAgICAgICAgICApKX1cbiAgICAgICAgPC9nPlxuICAgICAgKVxuICAgIH1cblxuICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCB9ID0gZ2V0RGltZW5zaW9ucygpXG5cbiAgICByZXR1cm4gKFxuICAgICAgPGFydGljbGVcbiAgICAgICAgcmVmPXtyZWZ9XG4gICAgICAgIGNsYXNzTmFtZT17TkFNRVNQQUNFfVxuICAgICAgICBzdHlsZT17eyAuLi5zdHlsZVByb3AsIC4uLnN0eWxlcy5jb250YWluZXIoZm9udFNpemUpIH19XG4gICAgICA+XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPXtnZXRDbGFzc05hbWUoJ3Njcm9sbC1jb250YWluZXInKX0gc3R5bGU9e3N0eWxlcy5zY3JvbGxDb250YWluZXIoZm9udFNpemUpfT5cbiAgICAgICAgICA8c3ZnXG4gICAgICAgICAgICB3aWR0aD17d2lkdGh9XG4gICAgICAgICAgICBoZWlnaHQ9e2hlaWdodH1cbiAgICAgICAgICAgIHZpZXdCb3g9e2AwIDAgJHt3aWR0aH0gJHtoZWlnaHR9YH1cbiAgICAgICAgICAgIGNsYXNzTmFtZT17Z2V0Q2xhc3NOYW1lKCdjYWxlbmRhcicpfVxuICAgICAgICAgICAgc3R5bGU9e3sgLi4uc3R5bGVzLmNhbGVuZGFyLCBtYXJnaW5MZWZ0OiB3ZWVrZGF5TGFiZWxPZmZzZXQgfX1cbiAgICAgICAgICA+XG4gICAgICAgICAgICB7IWxvYWRpbmcgJiYgcmVuZGVyV2Vla2RheUxhYmVscygpfVxuICAgICAgICAgICAgeyFsb2FkaW5nICYmIHJlbmRlck1vbnRoTGFiZWxzKCl9XG4gICAgICAgICAgICB7cmVuZGVyQ2FsZW5kYXIoKX1cbiAgICAgICAgICA8L3N2Zz5cbiAgICAgICAgPC9kaXY+XG4gICAgICAgIHtyZW5kZXJGb290ZXIoKX1cbiAgICAgIDwvYXJ0aWNsZT5cbiAgICApXG4gIH0sXG4pXG5cbkFjdGl2aXR5Q2FsZW5kYXIuZGlzcGxheU5hbWUgPSAnQWN0aXZpdHlDYWxlbmRhcidcblxuZXhwb3J0IGNvbnN0IFNrZWxldG9uID0gKHByb3BzOiBPbWl0PFByb3BzLCAnZGF0YSc+KSA9PiA8QWN0aXZpdHlDYWxlbmRhciBkYXRhPXtbXX0gey4uLnByb3BzfSAvPlxuIl0sIm5hbWVzIjpbIk5BTUVTUEFDRSIsIkxBQkVMX01BUkdJTiIsIkRFRkFVTFRfTU9OVEhfTEFCRUxTIiwiREVGQVVMVF9MQUJFTFMiLCJtb250aHMiLCJ3ZWVrZGF5cyIsInRvdGFsQ291bnQiLCJsZWdlbmQiLCJsZXNzIiwibW9yZSIsInVzZUNvbG9yU2NoZW1lIiwiY29sb3JTY2hlbWUiLCJzZXRDb2xvclNjaGVtZSIsInVzZVN0YXRlIiwib25DaGFuZ2UiLCJldmVudCIsIm1hdGNoZXMiLCJ1c2VFZmZlY3QiLCJtZWRpYVF1ZXJ5Iiwid2luZG93IiwibWF0Y2hNZWRpYSIsImFkZEV2ZW50TGlzdGVuZXIiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwibG9hZGluZ0FuaW1hdGlvbk5hbWUiLCJ1c2VMb2FkaW5nQW5pbWF0aW9uIiwiemVyb0NvbG9yIiwiY29sb3JMb2FkaW5nIiwiY29sb3JBY3RpdmUiLCJzdHlsZSIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsImlubmVySFRNTCIsImhlYWQiLCJhcHBlbmRDaGlsZCIsInJlbW92ZUNoaWxkIiwicXVlcnkiLCJ1c2VQcmVmZXJzUmVkdWNlZE1vdGlvbiIsInByZWZlcnNSZWR1Y2VkTW90aW9uIiwic2V0UHJlZmVyc1JlZHVjZWRNb3Rpb24iLCJ2YWxpZGF0ZUFjdGl2aXRpZXMiLCJhY3Rpdml0aWVzIiwibWF4TGV2ZWwiLCJsZW5ndGgiLCJFcnJvciIsImRhdGUiLCJsZXZlbCIsImNvdW50IiwiaXNWYWxpZCIsInBhcnNlSVNPIiwiUmFuZ2VFcnJvciIsImdyb3VwQnlXZWVrcyIsIndlZWtTdGFydCIsIm5vcm1hbGl6ZWRBY3Rpdml0aWVzIiwiZmlsbEhvbGVzIiwiZmlyc3RBY3Rpdml0eSIsImZpcnN0RGF0ZSIsImZpcnN0Q2FsZW5kYXJEYXRlIiwiZ2V0RGF5Iiwic3ViV2Vla3MiLCJuZXh0RGF5IiwicGFkZGVkQWN0aXZpdGllcyIsIkFycmF5IiwiZGlmZmVyZW5jZUluQ2FsZW5kYXJEYXlzIiwiZmlsbCIsInVuZGVmaW5lZCIsIm51bWJlck9mV2Vla3MiLCJNYXRoIiwiY2VpbCIsInJhbmdlIiwibWFwIiwid2Vla0luZGV4Iiwic2xpY2UiLCJjYWxlbmRhciIsIk1hcCIsImEiLCJsYXN0QWN0aXZpdHkiLCJlYWNoRGF5T2ZJbnRlcnZhbCIsInN0YXJ0IiwiZW5kIiwiZGF5IiwiZm9ybWF0SVNPIiwicmVwcmVzZW50YXRpb24iLCJoYXMiLCJnZXQiLCJnZXRDbGFzc05hbWUiLCJuYW1lIiwiZ2VuZXJhdGVFbXB0eURhdGEiLCJ5ZWFyIiwiRGF0ZSIsImdldEZ1bGxZZWFyIiwiZGF5cyIsIm4iLCJrZXlzIiwiZ2V0TW9udGhMYWJlbHMiLCJ3ZWVrcyIsIm1vbnRoTmFtZXMiLCJyZWR1Y2UiLCJsYWJlbHMiLCJ3ZWVrIiwiZmluZCIsImFjdGl2aXR5IiwibW9udGgiLCJnZXRNb250aCIsIm1vbnRoTmFtZSIsInRvTG9jYWxlU3RyaW5nIiwicHJldkxhYmVsIiwibGFiZWwiLCJmaWx0ZXIiLCJpbmRleCIsIm1pbldlZWtzIiwibWF4V2Vla2RheUxhYmVsV2lkdGgiLCJzaG93V2Vla2RheUxhYmVsIiwiZm9udFNpemUiLCJtYXhXaWR0aCIsImJ5RGF5SW5kZXgiLCJtYXgiLCJjYWxjVGV4dERpbWVuc2lvbnMiLCJ3aWR0aCIsInRleHQiLCJoZWlnaHQiLCJuYW1lc3BhY2UiLCJzdmciLCJjcmVhdGVFbGVtZW50TlMiLCJwb3NpdGlvbiIsInZpc2liaWxpdHkiLCJmb250RmFtaWx5IiwiZ2V0Q29tcHV0ZWRTdHlsZSIsImJvZHkiLCJ0ZXh0Tm9kZSIsInRleHRDb250ZW50IiwiYm91bmRpbmdCb3giLCJnZXRCQm94IiwiaW5pdFdlZWtkYXlMYWJlbHMiLCJpbnB1dCIsInNob3VsZFNob3ciLCJpbmRleGVkIiwiZGF5TmFtZVRvSW5kZXgiLCJ0b0xvd2VyQ2FzZSIsInN1biIsIm1vbiIsInR1ZSIsIndlZCIsInRodSIsImZyaSIsInNhdCIsImNyZWF0ZVRoZW1lIiwic3RlcHMiLCJkZWZhdWx0VGhlbWUiLCJjcmVhdGVEZWZhdWx0VGhlbWUiLCJ2YWxpZGF0ZUlucHV0IiwibGlnaHQiLCJkYXJrIiwiaXNQYWlyIiwiY2FsY0NvbG9yU2NhbGUiLCJjIiwiQ1NTIiwic3VwcG9ydHMiLCJTdHJpbmciLCJpIiwicG9zIiwicGFyc2VGbG9hdCIsInRvRml4ZWQiLCJ2YWwiLCJzdHlsZXMiLCJjb250YWluZXIiLCJkaXNwbGF5IiwiZmxleERpcmVjdGlvbiIsImdhcCIsInNjcm9sbENvbnRhaW5lciIsIm92ZXJmbG93WCIsIm92ZXJmbG93WSIsInBhZGRpbmdUb3AiLCJvdmVyZmxvdyIsInJlY3QiLCJzdHJva2UiLCJmb290ZXIiLCJmbGV4V3JhcCIsIndoaXRlU3BhY2UiLCJtYXJnaW5MZWZ0IiwiYWxpZ25JdGVtcyIsIkFjdGl2aXR5Q2FsZW5kYXIiLCJmb3J3YXJkUmVmIiwiZGF0YSIsImJsb2NrTWFyZ2luIiwiYmxvY2tSYWRpdXMiLCJibG9ja1NpemUiLCJjb2xvclNjaGVtZVByb3AiLCJldmVudEhhbmRsZXJzIiwiaGlkZUNvbG9yTGVnZW5kIiwiaGlkZU1vbnRoTGFiZWxzIiwiaGlkZVRvdGFsQ291bnQiLCJsYWJlbHNQcm9wIiwibG9hZGluZyIsInJlbmRlckJsb2NrIiwicmVuZGVyQ29sb3JMZWdlbmQiLCJzaG93V2Vla2RheUxhYmVscyIsInN0eWxlUHJvcCIsInRoZW1lIiwidGhlbWVQcm9wIiwidG90YWxDb3VudFByb3AiLCJyZWYiLCJpc0NsaWVudCIsInNldElzQ2xpZW50Iiwic3lzdGVtQ29sb3JTY2hlbWUiLCJjb2xvclNjYWxlIiwidXNlQW5pbWF0aW9uIiwiZ2V0WWVhciIsIk9iamVjdCIsImFzc2lnbiIsImxhYmVsSGVpZ2h0Iiwid2Vla2RheUxhYmVscyIsIndlZWtkYXlMYWJlbE9mZnNldCIsImdldERpbWVuc2lvbnMiLCJnZXRFdmVudEhhbmRsZXJzIiwiaGFuZGxlcnMiLCJrZXkiLCJyZW5kZXJDYWxlbmRhciIsImRheUluZGV4IiwibG9hZGluZ0FuaW1hdGlvbiIsImFuaW1hdGlvbiIsImFuaW1hdGlvbkRlbGF5IiwiYmxvY2siLCJfanN4IiwieCIsInkiLCJyeCIsInJ5IiwiRnJhZ21lbnQiLCJjaGlsZHJlbiIsInRyYW5zZm9ybSIsInJlbmRlckZvb3RlciIsInN1bSIsIl9qc3hzIiwiY2xhc3NOYW1lIiwicmVwbGFjZSIsIm1hcmdpblJpZ2h0IiwicmVuZGVyV2Vla2RheUxhYmVscyIsImRvbWluYW50QmFzZWxpbmUiLCJ0ZXh0QW5jaG9yIiwicmVuZGVyTW9udGhMYWJlbHMiLCJ2aWV3Qm94IiwiZGlzcGxheU5hbWUiLCJTa2VsZXRvbiIsInByb3BzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-activity-calendar/build/index.js\n");

/***/ })

};
;